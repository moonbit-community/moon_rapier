// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_rapier/dynamics"

import {
  "Milky2018/moon_rapier/core",
}

// Values

// Errors

// Types and methods
pub struct CCDSolver {
}
pub fn CCDSolver::clamp_motions(Self, Float, RigidBodySet, PredictedImpacts) -> Unit
pub fn CCDSolver::new() -> Self
pub fn CCDSolver::update_ccd_active_flags(Self, IslandManager, RigidBodySet, Float, Bool) -> Bool

pub(all) enum CoefficientCombineRule {
  Average
  Min
  Multiply
  Max
  ClampedSum
}
pub fn CoefficientCombineRule::combine(Float, Float, Self, Self) -> Float

pub struct ContactGraph {
  pairs : Array[(RigidBodyHandle, RigidBodyHandle)]
}
pub fn ContactGraph::add_pair(Self, RigidBodyHandle, RigidBodyHandle) -> Unit
pub fn ContactGraph::clear(Self) -> Unit
pub fn ContactGraph::new() -> Self

type DVector
pub fn DVector::equals(Self, Self) -> Bool
pub fn DVector::from_array(Array[Float]) -> Self
pub fn DVector::from_fn(Int, (Int) -> Float) -> Self
pub fn DVector::len(Self) -> Int
pub fn DVector::scale_in_place(Self, Float) -> Unit

pub struct GenericJoint {
  mut local_frame1 : @core.Isometry2
  mut local_frame2 : @core.Isometry2
  mut locked_axes : JointAxesMask
  mut limit_axes : JointAxesMask
  mut motor_axes : JointAxesMask
  mut coupled_axes : JointAxesMask
  mut limits : JointLimits3
  mut motors : JointMotors3
  mut softness : SpringCoefficients
  mut contacts_enabled : Bool
  mut enabled : JointEnabled
  user_data : Int
}
pub fn GenericJoint::contacts_enabled(Self) -> Bool
pub fn GenericJoint::coupled_axes(Self) -> JointAxesMask
pub fn GenericJoint::default() -> Self
pub fn GenericJoint::from_revolute(RevoluteJoint) -> Self
pub fn GenericJoint::is_enabled(Self) -> Bool
pub fn GenericJoint::limit_axes(Self) -> JointAxesMask
pub fn GenericJoint::limits(Self) -> JointLimits3
pub fn GenericJoint::local_anchor1(Self) -> @core.Vec2
pub fn GenericJoint::local_anchor2(Self) -> @core.Vec2
pub fn GenericJoint::local_frame1(Self) -> @core.Isometry2
pub fn GenericJoint::local_frame2(Self) -> @core.Isometry2
pub fn GenericJoint::locked_axes(Self) -> JointAxesMask
pub fn GenericJoint::motor_axes(Self) -> JointAxesMask
pub fn GenericJoint::motors(Self) -> JointMotors3
pub fn GenericJoint::new(JointAxesMask) -> Self
pub fn GenericJoint::set_contacts_enabled(Self, Bool) -> Self
pub fn GenericJoint::set_coupled_axes(Self, JointAxesMask) -> Self
pub fn GenericJoint::set_enabled(Self, Bool) -> Self
pub fn GenericJoint::set_enabled_by_attached_body(Self, Bool) -> Self
pub fn GenericJoint::set_limit_axes(Self, JointAxesMask) -> Self
pub fn GenericJoint::set_limits(Self, JointLimits3) -> Self
pub fn GenericJoint::set_local_anchor1(Self, @core.Vec2) -> Self
pub fn GenericJoint::set_local_anchor2(Self, @core.Vec2) -> Self
pub fn GenericJoint::set_local_frame1(Self, @core.Isometry2) -> Self
pub fn GenericJoint::set_local_frame2(Self, @core.Isometry2) -> Self
pub fn GenericJoint::set_locked_axes(Self, JointAxesMask) -> Self
pub fn GenericJoint::set_motor_axes(Self, JointAxesMask) -> Self
pub fn GenericJoint::set_motors(Self, JointMotors3) -> Self
pub fn GenericJoint::set_softness(Self, SpringCoefficients) -> Self
pub fn GenericJoint::softness(Self) -> SpringCoefficients

pub struct Group {
  value : Int
}
pub fn Group::all() -> Self
pub fn Group::bits(Self) -> Int
pub fn Group::equals(Self, Self) -> Bool
pub fn Group::group_1() -> Self
pub fn Group::group_10() -> Self
pub fn Group::group_11() -> Self
pub fn Group::group_12() -> Self
pub fn Group::group_13() -> Self
pub fn Group::group_14() -> Self
pub fn Group::group_15() -> Self
pub fn Group::group_16() -> Self
pub fn Group::group_2() -> Self
pub fn Group::group_3() -> Self
pub fn Group::group_4() -> Self
pub fn Group::group_5() -> Self
pub fn Group::group_6() -> Self
pub fn Group::group_7() -> Self
pub fn Group::group_8() -> Self
pub fn Group::group_9() -> Self
pub fn Group::intersection(Self, Self) -> Self
pub fn Group::new(Int) -> Self
pub fn Group::none() -> Self
pub fn Group::or(Self, Self) -> Self

pub struct ImpulseJoint {
  body1 : RigidBodyHandle
  body2 : RigidBodyHandle
  mut data : GenericJoint
  mut impulses : @core.Vec2
  handle : ImpulseJointHandle
}
pub fn ImpulseJoint::is_enabled(Self) -> Bool
pub fn ImpulseJoint::set_enabled(Self, Bool) -> Self
pub fn ImpulseJoint::set_enabled_by_attached_body(Self, Bool) -> Self

pub struct ImpulseJointGraph {
  nodes : Array[RigidBodyHandle]
  edges : Array[(RigidBodyHandle, RigidBodyHandle, ImpulseJoint)]
}
pub fn ImpulseJointGraph::edges(Self) -> Array[(RigidBodyHandle, RigidBodyHandle, ImpulseJoint)]
pub fn ImpulseJointGraph::nodes(Self) -> Array[RigidBodyHandle]

pub struct ImpulseJointHandle {
  id : Int
  generation : Int
}
pub fn ImpulseJointHandle::from_raw_parts(Int, Int) -> Self
pub fn ImpulseJointHandle::into_raw_parts(Self) -> (Int, Int)
pub fn ImpulseJointHandle::invalid() -> Self

type ImpulseJointSet
pub fn ImpulseJointSet::attached_enabled_joints(Self, RigidBodyHandle) -> Array[(RigidBodyHandle, RigidBodyHandle, ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::attached_joints(Self, RigidBodyHandle) -> Array[(RigidBodyHandle, RigidBodyHandle, ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::contains(Self, ImpulseJointHandle) -> Bool
pub fn ImpulseJointSet::get(Self, ImpulseJointHandle) -> ImpulseJoint?
pub fn ImpulseJointSet::get_mut(Self, ImpulseJointHandle, Bool) -> ImpulseJoint?
pub fn ImpulseJointSet::get_unknown_gen(Self, Int) -> (ImpulseJoint, ImpulseJointHandle)?
pub fn ImpulseJointSet::get_unknown_gen_mut(Self, Int) -> (ImpulseJoint, ImpulseJointHandle)?
pub fn ImpulseJointSet::insert(Self, RigidBodyHandle, RigidBodyHandle, GenericJoint, Bool) -> ImpulseJointHandle
pub fn ImpulseJointSet::is_empty(Self) -> Bool
pub fn ImpulseJointSet::iter(Self) -> Array[(ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::iter_mut(Self) -> Array[(ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::joint_graph(Self) -> ImpulseJointGraph
pub fn ImpulseJointSet::joints_between(Self, RigidBodyHandle, RigidBodyHandle) -> Array[(ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::len(Self) -> Int
pub fn ImpulseJointSet::map_attached_joints_mut(Self, RigidBodyHandle, (RigidBodyHandle, RigidBodyHandle, ImpulseJointHandle, ImpulseJoint) -> Unit) -> Unit
pub fn ImpulseJointSet::new() -> Self
pub fn ImpulseJointSet::remove(Self, ImpulseJointHandle, Bool) -> ImpulseJoint?
pub fn ImpulseJointSet::remove_joints_attached_to_rigid_body(Self, RigidBodyHandle) -> Array[ImpulseJointHandle]
pub fn ImpulseJointSet::select_active_interactions(Self, IslandManager, RigidBodySet, Array[Array[Int]]) -> Unit
pub fn ImpulseJointSet::set_enabled(Self, ImpulseJointHandle, Bool) -> Unit
pub fn ImpulseJointSet::set_impulses(Self, ImpulseJointHandle, @core.Vec2) -> Unit
pub fn ImpulseJointSet::take_to_join(Self) -> Array[(RigidBodyHandle, RigidBodyHandle)]
pub fn ImpulseJointSet::take_wake_up(Self) -> Array[RigidBodyHandle]

type IndexSequence
pub fn IndexSequence::inv_rearrange_rows(Self, DVector) -> Unit
pub fn IndexSequence::keep(Self, Int) -> Unit
pub fn IndexSequence::new() -> Self
pub fn IndexSequence::rearrange_columns(Self, RowDVector, Bool) -> Unit
pub fn IndexSequence::rearrange_rows(Self, DVector, Bool) -> Unit
pub fn IndexSequence::remove(Self, Int) -> Unit
pub fn IndexSequence::with_rearranged_rows_mut(Self, DVector, (DVector) -> Unit) -> Unit

pub struct IntegrationParameters {
  mut dt : Float
  mut min_ccd_dt : Float
  mut contact_softness : SpringCoefficients
  mut warmstart_coefficient : Float
  mut length_unit : Float
  mut normalized_allowed_linear_error : Float
  mut normalized_max_corrective_velocity : Float
  mut normalized_prediction_distance : Float
  mut num_solver_iterations : Int
  mut num_internal_pgs_iterations : Int
  mut num_internal_stabilization_iterations : Int
  mut min_island_size : Int
  mut max_ccd_substeps : Int
}
pub fn IntegrationParameters::allowed_linear_error(Self) -> Float
pub fn IntegrationParameters::default() -> Self
pub fn IntegrationParameters::inv_dt(Self) -> Float
pub fn IntegrationParameters::max_corrective_velocity(Self) -> Float
pub fn IntegrationParameters::new() -> Self
pub fn IntegrationParameters::prediction_distance(Self) -> Float
pub fn IntegrationParameters::set_contact_softness(Self, SpringCoefficients) -> Self
pub fn IntegrationParameters::set_dt(Self, Float) -> Self
pub fn IntegrationParameters::set_inv_dt(Self, Float) -> Self
pub fn IntegrationParameters::set_length_unit(Self, Float) -> Self
pub fn IntegrationParameters::set_max_ccd_substeps(Self, Int) -> Self
pub fn IntegrationParameters::set_min_ccd_dt(Self, Float) -> Self
pub fn IntegrationParameters::set_min_island_size(Self, Int) -> Self
pub fn IntegrationParameters::set_normalized_allowed_linear_error(Self, Float) -> Self
pub fn IntegrationParameters::set_normalized_max_corrective_velocity(Self, Float) -> Self
pub fn IntegrationParameters::set_normalized_prediction_distance(Self, Float) -> Self
pub fn IntegrationParameters::set_num_internal_pgs_iterations(Self, Int) -> Self
pub fn IntegrationParameters::set_num_internal_stabilization_iterations(Self, Int) -> Self
pub fn IntegrationParameters::set_num_solver_iterations(Self, Int) -> Self
pub fn IntegrationParameters::set_warmstart_coefficient(Self, Float) -> Self

pub struct InteractionGroups {
  mut memberships : Group
  mut filter : Group
  test_mode : InteractionTestMode
}
pub fn InteractionGroups::all() -> Self
pub fn InteractionGroups::default() -> Self
pub fn InteractionGroups::filter(Self) -> Group
pub fn InteractionGroups::memberships(Self) -> Group
pub fn InteractionGroups::new(Group, Group, InteractionTestMode) -> Self
pub fn InteractionGroups::none() -> Self
pub fn InteractionGroups::test_and(Self, Self) -> Bool
pub fn InteractionGroups::test_groups(Self, Self) -> Bool
pub fn InteractionGroups::test_mode(Self) -> InteractionTestMode
pub fn InteractionGroups::test_or(Self, Self) -> Bool
pub fn InteractionGroups::with_filter(Self, Group) -> Self
pub fn InteractionGroups::with_memberships(Self, Group) -> Self

pub(all) enum InteractionTestMode {
  And
  Or
}

type Island

pub struct IslandManager {
  islands : Array[Island?]
  awake_islands : Array[Int]
  free_islands : Array[Int]
  traversal_candidates : Array[SleepCandidate]
  mut traversal_timestamp : Int
  optimizer : IslandsOptimizer
  stack : Array[RigidBodyHandle]
  body_island_ids : Array[Int]
  body_island_generations : Array[Int]
  body_island_indices : Array[Int]
  body_state_generations : Array[Int]
}
pub fn IslandManager::active_bodies(Self) -> Array[RigidBodyHandle]
pub fn IslandManager::interaction_started_or_stopped(Self, RigidBodySet, RigidBodyHandle?, RigidBodyHandle?, Bool, Bool) -> Unit
pub fn IslandManager::new() -> Self
pub fn IslandManager::rigid_body_removed_or_disabled(Self, RigidBodyHandle, RigidBodySet) -> Unit
pub fn IslandManager::rigid_body_updated(Self, RigidBodyHandle, RigidBodySet) -> Unit
pub fn IslandManager::update_islands(Self, Float, Float, RigidBodySet, ContactGraph, ImpulseJointSet, MultibodyJointSet) -> Unit
pub fn IslandManager::wake_up(Self, RigidBodySet, RigidBodyHandle, Bool) -> Unit

type IslandsOptimizer

type Jacobian
pub fn Jacobian::cols(Self) -> Int
pub fn Jacobian::equals(Self, Self) -> Bool
pub fn Jacobian::spatial_dim() -> Int
pub fn Jacobian::value_at(Self, Int, Int) -> Float
pub fn Jacobian::zeros(Int) -> Self

pub struct JointAxesMask {
  bits : Int
}
pub fn JointAxesMask::ang_axes() -> Self
pub fn JointAxesMask::ang_z() -> Self
pub fn JointAxesMask::bits(Self) -> Int
pub fn JointAxesMask::contains(Self, Self) -> Bool
pub fn JointAxesMask::empty() -> Self
pub fn JointAxesMask::intersection(Self, Self) -> Self
pub fn JointAxesMask::lin_axes() -> Self
pub fn JointAxesMask::lin_x() -> Self
pub fn JointAxesMask::lin_y() -> Self
pub fn JointAxesMask::locked_revolute_axes() -> Self
pub fn JointAxesMask::new(Int) -> Self
pub fn JointAxesMask::or(Self, Self) -> Self

pub(all) enum JointAxis {
  LinX
  LinY
  AngZ
}

pub(all) enum JointEnabled {
  Enabled
  DisabledByAttachedBody
  Disabled
}

pub struct JointLimits {
  min : Float
  max : Float
  mut impulse : Float
}
pub fn JointLimits::clear_impulse(Self) -> Self
pub fn JointLimits::default() -> Self

pub struct JointLimits3 {
  lin_x : JointLimits
  lin_y : JointLimits
  ang_z : JointLimits
}
pub fn JointLimits3::default() -> Self

pub struct JointMotor {
  target_vel : Float
  target_pos : Float
  stiffness : Float
  damping : Float
  max_force : Float
  mut impulse : Float
  model : MotorModel
}
pub fn JointMotor::clear_impulse(Self) -> Self
pub fn JointMotor::default() -> Self

pub struct JointMotors3 {
  lin_x : JointMotor
  lin_y : JointMotor
  ang_z : JointMotor
}
pub fn JointMotors3::default() -> Self

pub struct LinkId {
  value : Int
}

pub(all) enum MotorModel {
  AccelerationBased
  ForceBased
}

type Multibody
pub fn Multibody::apply_displacements(Self, Array[Float]) -> Unit
pub fn Multibody::body_jacobian(Self, LinkId) -> Jacobian
pub fn Multibody::forward_kinematics(Self, RigidBodySet, Bool) -> Unit
pub fn Multibody::forward_kinematics_single_link(Self, RigidBodySet, LinkId, Array[Float]?, Jacobian?) -> @core.Isometry2
pub fn Multibody::link(Self, LinkId) -> MultibodyLink?
pub fn Multibody::ndofs(Self) -> Int

pub struct MultibodyIndex {
  value : Int
}
pub fn MultibodyIndex::invalid() -> Self

type MultibodyJointHandle
pub fn MultibodyJointHandle::from_raw_parts(Int, Int) -> Self
pub fn MultibodyJointHandle::into_raw_parts(Self) -> (Int, Int)
pub fn MultibodyJointHandle::invalid() -> Self

type MultibodyJointSet
pub fn MultibodyJointSet::attached_bodies(Self, RigidBodyHandle) -> Array[RigidBodyHandle]
pub fn MultibodyJointSet::attached_joints(Self, RigidBodyHandle) -> Array[(RigidBodyHandle, RigidBodyHandle, MultibodyJointHandle)]
pub fn MultibodyJointSet::bodies_attached_with_enabled_joint(Self, RigidBodyHandle) -> Array[RigidBodyHandle]
pub fn MultibodyJointSet::get(Self, MultibodyJointHandle) -> (Multibody, LinkId)?
pub fn MultibodyJointSet::get_multibody(Self, MultibodyIndex) -> Multibody?
pub fn MultibodyJointSet::get_multibody_mut(Self, MultibodyIndex) -> Multibody?
pub fn MultibodyJointSet::get_multibody_mut_internal(Self, MultibodyIndex) -> Multibody?
pub fn MultibodyJointSet::get_mut(Self, MultibodyJointHandle) -> (Multibody, LinkId)?
pub fn MultibodyJointSet::get_mut_internal(Self, MultibodyJointHandle) -> (Multibody, LinkId)?
pub fn MultibodyJointSet::get_unknown_gen(Self, Int) -> (Multibody, LinkId, MultibodyJointHandle)?
pub fn MultibodyJointSet::insert(Self, RigidBodyHandle, RigidBodyHandle, RevoluteJoint, Bool) -> MultibodyJointHandle?
pub fn MultibodyJointSet::insert_kinematic(Self, RigidBodyHandle, RigidBodyHandle, RevoluteJoint, Bool) -> MultibodyJointHandle?
pub fn MultibodyJointSet::iter(Self) -> Array[(MultibodyJointHandle, MultibodyLinkId, Multibody, MultibodyLink)]
pub fn MultibodyJointSet::joint_between(Self, RigidBodyHandle, RigidBodyHandle) -> (MultibodyJointHandle, Multibody, MultibodyLink)?
pub fn MultibodyJointSet::multibodies(Self) -> Array[Multibody]
pub fn MultibodyJointSet::new() -> Self
pub fn MultibodyJointSet::remove(Self, MultibodyJointHandle, Bool) -> Unit
pub fn MultibodyJointSet::remove_multibody_articulations(Self, RigidBodyHandle, Bool) -> Unit
pub fn MultibodyJointSet::rigid_body_link(Self, RigidBodyHandle) -> MultibodyLinkId?
pub fn MultibodyJointSet::take_to_join(Self) -> Array[(RigidBodyHandle, RigidBodyHandle)]
pub fn MultibodyJointSet::take_wake_up(Self) -> Array[RigidBodyHandle]

type MultibodyLink
pub fn MultibodyLink::local_to_world(Self) -> @core.Isometry2

pub struct MultibodyLinkId {
  multibody : MultibodyIndex
  id : Int
}

pub(all) enum PredictedImpacts {
  Impacts(Array[(RigidBodyHandle, Float)])
  ImpactsAfterEndTime(Float)
  NoImpacts
}

type RevoluteJoint
pub fn RevoluteJoint::angle(Self, @core.Rot2, @core.Rot2) -> Float
pub fn RevoluteJoint::local_anchor1(Self) -> @core.Vec2
pub fn RevoluteJoint::local_anchor2(Self) -> @core.Vec2

type RevoluteJointBuilder
pub fn RevoluteJointBuilder::build(Self) -> RevoluteJoint
pub fn RevoluteJointBuilder::local_anchor1(Self, @core.Vec2) -> Self
pub fn RevoluteJointBuilder::local_anchor2(Self, @core.Vec2) -> Self
pub fn RevoluteJointBuilder::new() -> Self

pub struct RigidBody {
  mut ids : RigidBodyIds
  position : RigidBodyPosition
  mut body_type : RigidBodyType
  dominance : RigidBodyDominance
  mut enabled : Bool
  mut activation : RigidBodyActivation
  mut damping : RigidBodyDamping
  mut vels : RigidBodyVelocity
  mut forces : RigidBodyForces
  mut ccd : RigidBodyCcd
  mut mass_props : RigidBodyMassProps
  mut additional_mass : Float
  mut additional_solver_iterations : Int
  mut changes : RigidBodyChanges
}
pub fn RigidBody::activation(Self) -> RigidBodyActivation
pub fn RigidBody::add_force(Self, @core.Vec2, Bool) -> Self
pub fn RigidBody::add_force_at_point(Self, @core.Vec2, @core.Vec2, Bool) -> Self
pub fn RigidBody::add_torque(Self, Float, Bool) -> Self
pub fn RigidBody::additional_mass(Self) -> Float
pub fn RigidBody::additional_solver_iterations(Self) -> Int
pub fn RigidBody::angular_damping(Self) -> Float
pub fn RigidBody::angvel(Self) -> Float
pub fn RigidBody::apply_impulse(Self, @core.Vec2, Bool) -> Self
pub fn RigidBody::apply_impulse_at_point(Self, @core.Vec2, @core.Vec2, Bool) -> Self
pub fn RigidBody::apply_torque_impulse(Self, Float, Bool) -> Self
pub fn RigidBody::body_type(Self) -> RigidBodyType
pub fn RigidBody::ccd(Self) -> RigidBodyCcd
pub fn RigidBody::center_of_mass(Self) -> @core.Vec2
pub fn RigidBody::clear_changes(Self) -> Self
pub fn RigidBody::damping(Self) -> RigidBodyDamping
pub fn RigidBody::dominance_group(Self) -> Int
pub fn RigidBody::effective_dominance_group(Self) -> Int
pub fn RigidBody::enable_ccd(Self, Bool) -> Self
pub fn RigidBody::forces(Self) -> RigidBodyForces
pub fn RigidBody::gravity_scale(Self) -> Float
pub fn RigidBody::inertia(Self) -> Float
pub fn RigidBody::inv_inertia(Self) -> Float
pub fn RigidBody::inv_mass(Self) -> Float
pub fn RigidBody::is_ccd_active(Self) -> Bool
pub fn RigidBody::is_ccd_enabled(Self) -> Bool
pub fn RigidBody::is_dynamic(Self) -> Bool
pub fn RigidBody::is_dynamic_or_kinematic(Self) -> Bool
pub fn RigidBody::is_enabled(Self) -> Bool
pub fn RigidBody::is_fixed(Self) -> Bool
pub fn RigidBody::is_kinematic(Self) -> Bool
pub fn RigidBody::is_sleeping(Self) -> Bool
pub fn RigidBody::linear_damping(Self) -> Float
pub fn RigidBody::linvel(Self) -> @core.Vec2
pub fn RigidBody::mark_local_mass_properties_changed(Self) -> Self
pub fn RigidBody::mass(Self) -> Float
pub fn RigidBody::mass_props(Self) -> RigidBodyMassProps
pub fn RigidBody::next_position(Self) -> @core.Isometry2
pub fn RigidBody::position(Self) -> @core.Isometry2
pub fn RigidBody::reset_forces(Self, Bool) -> Self
pub fn RigidBody::reset_torques(Self, Bool) -> Self
pub fn RigidBody::rotation(Self) -> @core.Rot2
pub fn RigidBody::set_additional_mass(Self, Float, Bool) -> Self
pub fn RigidBody::set_additional_solver_iterations(Self, Int) -> Self
pub fn RigidBody::set_angular_damping(Self, Float) -> Self
pub fn RigidBody::set_angvel(Self, Float, Bool) -> Self
pub fn RigidBody::set_body_type(Self, RigidBodyType, Bool) -> Self
pub fn RigidBody::set_ccd_properties(Self, Float, Float) -> Self
pub fn RigidBody::set_dominance_group(Self, Int) -> Self
pub fn RigidBody::set_enabled(Self, Bool) -> Self
pub fn RigidBody::set_gravity_scale(Self, Float, Bool) -> Self
pub fn RigidBody::set_kinematic_position_based_vels(Self, RigidBodyVelocity) -> Self
pub fn RigidBody::set_linear_damping(Self, Float) -> Self
pub fn RigidBody::set_linvel(Self, @core.Vec2, Bool) -> Self
pub fn RigidBody::set_local_mass_properties(Self, @core.MassProperties) -> Self
pub fn RigidBody::set_next_kinematic_position(Self, @core.Isometry2) -> Self
pub fn RigidBody::set_next_kinematic_rotation(Self, @core.Rot2) -> Self
pub fn RigidBody::set_next_kinematic_translation(Self, @core.Vec2) -> Self
pub fn RigidBody::set_next_position_internal(Self, @core.Isometry2) -> Self
pub fn RigidBody::set_position(Self, @core.Isometry2, Bool) -> Self
pub fn RigidBody::set_rotation(Self, @core.Rot2, Bool) -> Self
pub fn RigidBody::set_soft_ccd_prediction(Self, Float) -> Self
pub fn RigidBody::set_translation(Self, @core.Vec2, Bool) -> Self
pub fn RigidBody::set_vels(Self, RigidBodyVelocity, Bool) -> Self
pub fn RigidBody::sleep(Self) -> Self
pub fn RigidBody::soft_ccd_prediction(Self) -> Float
pub fn RigidBody::translation(Self) -> @core.Vec2
pub fn RigidBody::vels(Self) -> RigidBodyVelocity
pub fn RigidBody::wake_up(Self, Bool) -> Self
pub fn RigidBody::world_com(Self) -> @core.Vec2

pub struct RigidBodyActivation {
  mut normalized_linear_threshold : Float
  mut angular_threshold : Float
  mut time_until_sleep : Float
  mut time_since_can_sleep : Float
  mut sleeping : Bool
  mut sleep_root_state : SleepRootState
}
pub fn RigidBodyActivation::active() -> Self
pub fn RigidBodyActivation::cannot_sleep() -> Self
pub fn RigidBodyActivation::default() -> Self
pub fn RigidBodyActivation::default_angular_threshold() -> Float
pub fn RigidBodyActivation::default_normalized_linear_threshold() -> Float
pub fn RigidBodyActivation::default_time_until_sleep() -> Float
pub fn RigidBodyActivation::inactive() -> Self
pub fn RigidBodyActivation::is_active(Self) -> Bool
pub fn RigidBodyActivation::is_eligible_for_sleep(Self) -> Bool
pub fn RigidBodyActivation::sleep(Self) -> Self
pub fn RigidBodyActivation::update_energy(Self, RigidBodyType, Float, Float, Float, Float) -> Self
pub fn RigidBodyActivation::wake_up(Self, Bool) -> Self

pub struct RigidBodyBuilder {
  mut position : @core.Isometry2
  mut linvel : @core.Vec2
  mut angvel : Float
  mut gravity_scale : Float
  mut linear_damping : Float
  mut angular_damping : Float
  body_type : RigidBodyType
  mut additional_mass : Float
  mut additional_solver_iterations : Int
  mut can_sleep : Bool
  mut sleeping : Bool
  mut enabled : Bool
  mut ccd_enabled : Bool
  mut soft_ccd_prediction : Float
  mut dominance_group : Int
}
pub fn RigidBodyBuilder::additional_mass(Self, Float) -> Self
pub fn RigidBodyBuilder::additional_solver_iterations(Self, Int) -> Self
pub fn RigidBodyBuilder::angular_damping(Self, Float) -> Self
pub fn RigidBodyBuilder::angvel(Self, Float) -> Self
pub fn RigidBodyBuilder::build(Self) -> RigidBody
pub fn RigidBodyBuilder::can_sleep(Self, Bool) -> Self
pub fn RigidBodyBuilder::ccd_enabled(Self, Bool) -> Self
pub fn RigidBodyBuilder::dominance_group(Self, Int) -> Self
pub fn RigidBodyBuilder::dynamic() -> Self
pub fn RigidBodyBuilder::enabled(Self, Bool) -> Self
pub fn RigidBodyBuilder::fixed() -> Self
pub fn RigidBodyBuilder::gravity_scale(Self, Float) -> Self
pub fn RigidBodyBuilder::kinematic_position_based() -> Self
pub fn RigidBodyBuilder::kinematic_velocity_based() -> Self
pub fn RigidBodyBuilder::linear_damping(Self, Float) -> Self
pub fn RigidBodyBuilder::linvel(Self, @core.Vec2) -> Self
pub fn RigidBodyBuilder::position(Self, @core.Isometry2) -> Self
pub fn RigidBodyBuilder::rotation(Self, @core.Rot2) -> Self
pub fn RigidBodyBuilder::sleeping(Self, Bool) -> Self
pub fn RigidBodyBuilder::soft_ccd_prediction(Self, Float) -> Self
pub fn RigidBodyBuilder::translation(Self, @core.Vec2) -> Self

pub struct RigidBodyCcd {
  ccd_thickness : Float
  ccd_max_dist : Float
  ccd_active : Bool
  mut ccd_enabled : Bool
  mut soft_ccd_prediction : Float
}
pub fn RigidBodyCcd::default() -> Self
pub fn RigidBodyCcd::is_moving_fast(Self, Float, RigidBodyVelocity, RigidBodyForces?) -> Bool
pub fn RigidBodyCcd::max_point_velocity(Self, RigidBodyVelocity) -> Float

type RigidBodyChanges

pub struct RigidBodyDamping {
  mut linear_damping : Float
  mut angular_damping : Float
}
pub fn RigidBodyDamping::default() -> Self

pub struct RigidBodyDominance {
  mut group : Int
}
pub fn RigidBodyDominance::default() -> Self
pub fn RigidBodyDominance::effective_group(Self, RigidBodyType) -> Int
pub fn RigidBodyDominance::new(Int) -> Self

pub struct RigidBodyForces {
  mut force : @core.Vec2
  mut torque : Float
  mut gravity_scale : Float
  mut user_force : @core.Vec2
  mut user_torque : Float
}
pub fn RigidBodyForces::apply_force_at_point(Self, RigidBodyMassProps, @core.Vec2, @core.Vec2) -> Self
pub fn RigidBodyForces::compute_effective_force_and_torque(Self, @core.Vec2, @core.Vec2) -> Self
pub fn RigidBodyForces::default() -> Self
pub fn RigidBodyForces::integrate(Self, Float, RigidBodyVelocity, RigidBodyMassProps) -> RigidBodyVelocity

pub struct RigidBodyHandle {
  id : Int
  generation : Int
}
pub fn RigidBodyHandle::equals(Self, Self) -> Bool
pub fn RigidBodyHandle::from_raw_parts(Int, Int) -> Self
pub fn RigidBodyHandle::into_raw_parts(Self) -> (Int, Int)
pub fn RigidBodyHandle::invalid() -> Self

type RigidBodyIds

pub struct RigidBodyMassProps {
  mut world_com : @core.Vec2
  mut effective_inv_mass : @core.Vec2
  mut effective_world_inv_inertia : Float
  mut local_mprops : @core.MassProperties
}
pub fn RigidBodyMassProps::default() -> Self
pub fn RigidBodyMassProps::set_effective_inv_mass(Self, @core.Vec2) -> Self
pub fn RigidBodyMassProps::set_effective_world_inv_inertia(Self, Float) -> Self
pub fn RigidBodyMassProps::update_world_mass_properties(Self, RigidBodyType, @core.Isometry2) -> Self

pub struct RigidBodyPosition {
  mut position : @core.Isometry2
  mut next_position : @core.Isometry2
}
pub fn RigidBodyPosition::integrate_forces_and_velocities(Self, Float, RigidBodyForces, RigidBodyVelocity, RigidBodyMassProps) -> @core.Isometry2
pub fn RigidBodyPosition::interpolate_velocity(Self, Float, @core.Vec2) -> RigidBodyVelocity
pub fn RigidBodyPosition::new(@core.Isometry2, @core.Isometry2) -> Self

pub struct RigidBodySet {
  bodies : Array[RigidBody?]
  generations : Array[Int]
  free_list : Array[Int]
  modified_bodies : Array[RigidBodyHandle]
}
pub fn RigidBodySet::contains(Self, RigidBodyHandle) -> Bool
pub fn RigidBodySet::deserialize(String) -> Self
pub fn RigidBodySet::get(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet::get_mut(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet::get_mut_internal(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet::get_mut_internal_with_modification_tracking(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet::get_pair_mut(Self, RigidBodyHandle, RigidBodyHandle) -> (RigidBody?, RigidBody?)
pub fn RigidBodySet::get_unknown_gen(Self, Int) -> (RigidBody, RigidBodyHandle)?
pub fn RigidBodySet::get_unknown_gen_mut(Self, Int) -> (RigidBody, RigidBodyHandle)?
pub fn RigidBodySet::insert(Self, RigidBody) -> RigidBodyHandle
pub fn RigidBodySet::is_empty(Self) -> Bool
pub fn RigidBodySet::iter(Self) -> Array[(RigidBodyHandle, RigidBody)]
pub fn RigidBodySet::iter_mut(Self) -> Array[(RigidBodyHandle, RigidBody)]
pub fn RigidBodySet::len(Self) -> Int
pub fn RigidBodySet::new() -> Self
pub fn RigidBodySet::remove(Self, RigidBodyHandle, IslandManager, Unit, ImpulseJointSet, MultibodyJointSet, Bool) -> RigidBody?
pub fn RigidBodySet::serialize(Self) -> String
pub fn RigidBodySet::take_modified(Self) -> Array[RigidBodyHandle]
pub fn RigidBodySet::with_capacity(Int) -> Self

pub(all) enum RigidBodyType {
  Dynamic
  Fixed
  KinematicPositionBased
  KinematicVelocityBased
}
pub fn RigidBodyType::is_dynamic(Self) -> Bool
pub fn RigidBodyType::is_dynamic_or_kinematic(Self) -> Bool
pub fn RigidBodyType::is_fixed(Self) -> Bool
pub fn RigidBodyType::is_kinematic(Self) -> Bool

pub struct RigidBodyVelocity {
  mut linvel : @core.Vec2
  mut angvel : Float
}
pub fn RigidBodyVelocity::apply_damping(Self, Float, RigidBodyDamping) -> Self
pub fn RigidBodyVelocity::integrate(Self, Float, @core.Isometry2, @core.Vec2) -> @core.Isometry2
pub fn RigidBodyVelocity::zero() -> Self

type RowDVector
pub fn RowDVector::equals(Self, Self) -> Bool
pub fn RowDVector::from_array(Array[Float]) -> Self
pub fn RowDVector::from_fn(Int, (Int) -> Float) -> Self
pub fn RowDVector::len(Self) -> Int
pub fn RowDVector::scale(Self, Float) -> Self

type SleepCandidate

type SleepRootState

pub struct SpringCoefficients {
  natural_frequency : Float
  damping_ratio : Float
}
pub fn SpringCoefficients::angular_frequency(Self) -> Float
pub fn SpringCoefficients::cfm_coeff(Self, Float) -> Float
pub fn SpringCoefficients::cfm_factor(Self, Float) -> Float
pub fn SpringCoefficients::contact_defaults() -> Self
pub fn SpringCoefficients::erp(Self, Float) -> Float
pub fn SpringCoefficients::erp_inv_dt(Self, Float) -> Float
pub fn SpringCoefficients::joint_defaults() -> Self
pub fn SpringCoefficients::new(Float, Float) -> Self

// Type aliases

// Traits

