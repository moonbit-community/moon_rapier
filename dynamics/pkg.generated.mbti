// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_rapier/dynamics"

import {
  "Milky2018/moon_rapier/core",
}

// Values
pub fn unit_joint_limit_constraint(IntegrationParameters, Multibody, MultibodyLink, (Float, Float), Float, Int, Int, DVector, Array[GenericJointConstraint], Int) -> Unit

pub fn unit_joint_motor_constraint(IntegrationParameters, Multibody, MultibodyLink, JointMotor, Float, (Float, Float)?, Int, Int, DVector, Array[GenericJointConstraint], Int) -> Unit

// Errors

// Types and methods
pub struct AxesMask {
  bits : Int
}
pub fn AxesMask::all() -> Self
pub fn AxesMask::ang_axes() -> Self
pub fn AxesMask::ang_x() -> Self
pub fn AxesMask::ang_y() -> Self
pub fn AxesMask::ang_z() -> Self
pub fn AxesMask::bits(Self) -> Int
pub fn AxesMask::contains(Self, Self) -> Bool
pub fn AxesMask::empty() -> Self
pub fn AxesMask::insert(Self, Self) -> Self
pub fn AxesMask::lin_axes() -> Self
pub fn AxesMask::lin_x() -> Self
pub fn AxesMask::lin_y() -> Self
pub fn AxesMask::lin_z() -> Self
pub fn AxesMask::new(Int) -> Self
pub fn AxesMask::remove(Self, Self) -> Self

pub(all) enum AxisState3DReal {
  Free
  Locked
  Limited(Float, Float)
}

pub struct BodyPair {
  body1 : RigidBodyHandle
  body2 : RigidBodyHandle
}
pub fn BodyPair::new(RigidBodyHandle, RigidBodyHandle) -> Self

pub struct CCDSolver {
}
pub fn CCDSolver::clamp_motions(Self, Float, RigidBodySet, PredictedImpacts) -> Unit
pub fn CCDSolver::find_first_impact(Self, PredictedImpacts) -> (RigidBodyHandle, Float)?
pub fn CCDSolver::new() -> Self
pub fn CCDSolver::predict_impacts_at_next_positions(Self, RigidBodySet, Float) -> PredictedImpacts
pub fn CCDSolver::update_ccd_active_flags(Self, IslandManager, RigidBodySet, Float, Bool) -> Bool

pub(all) enum CoefficientCombineRule {
  Average
  Min
  Multiply
  Max
  ClampedSum
}
pub fn CoefficientCombineRule::combine(Float, Float, Self, Self) -> Float

pub struct ContactGraph {
  pairs : Array[(RigidBodyHandle, RigidBodyHandle)]
}
pub fn ContactGraph::add_pair(Self, RigidBodyHandle, RigidBodyHandle) -> Unit
pub fn ContactGraph::clear(Self) -> Unit
pub fn ContactGraph::new() -> Self

type DVector
pub fn DVector::as_array(Self) -> Array[Float]
pub fn DVector::equals(Self, Self) -> Bool
pub fn DVector::from_array(Array[Float]) -> Self
pub fn DVector::from_fn(Int, (Int) -> Float) -> Self
pub fn DVector::len(Self) -> Int
pub fn DVector::scale_in_place(Self, Float) -> Unit

pub struct FixedJoint {
  local_anchor1 : @core.Vec2
  local_anchor2 : @core.Vec2
}

pub struct FixedJoint3DRealBuilder {
  inner : GenericJoint3DRealBuilder
}
pub fn FixedJoint3DRealBuilder::build(Self) -> GenericJoint3DReal
pub fn FixedJoint3DRealBuilder::local_anchor1(Self, @core.Vec3) -> Self
pub fn FixedJoint3DRealBuilder::local_anchor2(Self, @core.Vec3) -> Self
pub fn FixedJoint3DRealBuilder::local_basis1(Self, @core.Quat) -> Self
pub fn FixedJoint3DRealBuilder::local_basis2(Self, @core.Quat) -> Self
pub fn FixedJoint3DRealBuilder::new() -> Self

type FixedJointBuilder
pub fn FixedJointBuilder::build(Self) -> FixedJoint
pub fn FixedJointBuilder::local_anchor1(Self, @core.Vec2) -> Self
pub fn FixedJointBuilder::local_anchor2(Self, @core.Vec2) -> Self
pub fn FixedJointBuilder::new() -> Self

pub enum FrictionModel {
  Simplified
  Coulomb
}
pub fn FrictionModel::coulomb() -> Self
pub fn FrictionModel::default() -> Self
pub fn FrictionModel::simplified() -> Self

pub struct GenericJoint {
  mut local_frame1 : @core.Isometry2
  mut local_frame2 : @core.Isometry2
  mut locked_axes : JointAxesMask
  mut limit_axes : JointAxesMask
  mut motor_axes : JointAxesMask
  mut coupled_axes : JointAxesMask
  mut limits : JointLimits3
  mut motors : JointMotors3
  mut softness : SpringCoefficients
  mut contacts_enabled : Bool
  mut enabled : JointEnabled
  user_data : Int
}
pub fn GenericJoint::as_fixed(Self) -> Self?
pub fn GenericJoint::as_fixed_mut(Self) -> Self?
pub fn GenericJoint::as_prismatic(Self) -> Self?
pub fn GenericJoint::as_prismatic_mut(Self) -> Self?
pub fn GenericJoint::as_revolute(Self) -> Self?
pub fn GenericJoint::as_revolute_mut(Self) -> Self?
pub fn GenericJoint::as_rope(Self) -> Self?
pub fn GenericJoint::as_rope_mut(Self) -> Self?
pub fn GenericJoint::as_spherical(Self) -> Self?
pub fn GenericJoint::as_spherical_mut(Self) -> Self?
pub fn GenericJoint::contacts_enabled(Self) -> Bool
pub fn GenericJoint::coupled_axes(Self) -> JointAxesMask
pub fn GenericJoint::default() -> Self
pub fn GenericJoint::flip(Self) -> Self
pub fn GenericJoint::from_fixed(FixedJoint) -> Self
pub fn GenericJoint::from_pin_slot(PinSlotJoint) -> Self
pub fn GenericJoint::from_prismatic(PrismaticJoint) -> Self
pub fn GenericJoint::from_revolute(RevoluteJoint) -> Self
pub fn GenericJoint::from_rope(RopeJoint) -> Self
pub fn GenericJoint::is_enabled(Self) -> Bool
pub fn GenericJoint::limit_axes(Self) -> JointAxesMask
pub fn GenericJoint::limits(Self) -> JointLimits3
pub fn GenericJoint::limits_axis(Self, JointAxis) -> JointLimits?
pub fn GenericJoint::local_anchor1(Self) -> @core.Vec2
pub fn GenericJoint::local_anchor2(Self) -> @core.Vec2
pub fn GenericJoint::local_frame1(Self) -> @core.Isometry2
pub fn GenericJoint::local_frame2(Self) -> @core.Isometry2
pub fn GenericJoint::lock_axes(Self, JointAxesMask) -> Self
pub fn GenericJoint::locked_axes(Self) -> JointAxesMask
pub fn GenericJoint::motor_axes(Self) -> JointAxesMask
pub fn GenericJoint::motors(Self) -> JointMotors3
pub fn GenericJoint::new(JointAxesMask) -> Self
pub fn GenericJoint::set_contacts_enabled(Self, Bool) -> Self
pub fn GenericJoint::set_coupled_axes(Self, JointAxesMask) -> Self
pub fn GenericJoint::set_enabled(Self, Bool) -> Self
pub fn GenericJoint::set_enabled_by_attached_body(Self, Bool) -> Self
pub fn GenericJoint::set_limit_axes(Self, JointAxesMask) -> Self
pub fn GenericJoint::set_limits(Self, JointLimits3) -> Self
pub fn GenericJoint::set_limits_axis(Self, JointAxis, Float, Float) -> Self
pub fn GenericJoint::set_local_anchor1(Self, @core.Vec2) -> Self
pub fn GenericJoint::set_local_anchor2(Self, @core.Vec2) -> Self
pub fn GenericJoint::set_local_frame1(Self, @core.Isometry2) -> Self
pub fn GenericJoint::set_local_frame2(Self, @core.Isometry2) -> Self
pub fn GenericJoint::set_locked_axes(Self, JointAxesMask) -> Self
pub fn GenericJoint::set_motor(Self, JointAxis, Float, Float, Float, Float) -> Self
pub fn GenericJoint::set_motor_axes(Self, JointAxesMask) -> Self
pub fn GenericJoint::set_motor_max_force(Self, JointAxis, Float) -> Self
pub fn GenericJoint::set_motor_model(Self, JointAxis, MotorModel) -> Self
pub fn GenericJoint::set_motor_position(Self, JointAxis, Float, Float, Float) -> Self
pub fn GenericJoint::set_motor_velocity(Self, JointAxis, Float, Float) -> Self
pub fn GenericJoint::set_motors(Self, JointMotors3) -> Self
pub fn GenericJoint::set_softness(Self, SpringCoefficients) -> Self
pub fn GenericJoint::softness(Self) -> SpringCoefficients

pub struct GenericJoint3DReal {
  local_frame1 : @core.Isometry3
  local_frame2 : @core.Isometry3
  axis_states : Array[AxisState3DReal]
  motors : Array[MotorState3DReal]
  coupled_axes : JointAxesMask3DReal
  contacts_enabled : Bool
}

pub struct GenericJoint3DRealBuilder {
  locked_axes : JointAxesMask3DReal
  mut contacts_enabled : Bool
  mut coupled_axes : JointAxesMask3DReal
  mut local_anchor1 : @core.Vec3
  mut local_anchor2 : @core.Vec3
  mut local_basis1 : @core.Quat
  mut local_basis2 : @core.Quat
  axis_states : Array[AxisState3DReal]
  motors : Array[MotorState3DReal]
}
pub fn GenericJoint3DRealBuilder::build(Self) -> GenericJoint3DReal
pub fn GenericJoint3DRealBuilder::contacts_enabled(Self, Bool) -> Self
pub fn GenericJoint3DRealBuilder::coupled_axes(Self, JointAxesMask3DReal) -> Self
pub fn GenericJoint3DRealBuilder::limits(Self, JointAxis3DReal, Float, Float) -> Self
pub fn GenericJoint3DRealBuilder::local_anchor1(Self, @core.Vec3) -> Self
pub fn GenericJoint3DRealBuilder::local_anchor2(Self, @core.Vec3) -> Self
pub fn GenericJoint3DRealBuilder::local_axis1(Self, @core.Vec3) -> Self
pub fn GenericJoint3DRealBuilder::local_axis2(Self, @core.Vec3) -> Self
pub fn GenericJoint3DRealBuilder::local_basis1(Self, @core.Quat) -> Self
pub fn GenericJoint3DRealBuilder::local_basis2(Self, @core.Quat) -> Self
pub fn GenericJoint3DRealBuilder::motor_max_force(Self, JointAxis3DReal, Float) -> Self
pub fn GenericJoint3DRealBuilder::motor_position(Self, JointAxis3DReal, Float, Float, Float) -> Self
pub fn GenericJoint3DRealBuilder::motor_velocity(Self, JointAxis3DReal, Float, Float) -> Self
pub fn GenericJoint3DRealBuilder::new(JointAxesMask3DReal) -> Self

pub struct GenericJointConstraint {
  is_rigid_body1 : Bool
  is_rigid_body2 : Bool
  solver_vel1 : Int
  solver_vel2 : Int
  ndofs1 : Int
  j_id1 : Int
  ndofs2 : Int
  j_id2 : Int
  joint_id : Int
  impulse : Float
  impulse_bounds : (Float, Float)
  inv_lhs : Float
  rhs : Float
  rhs_wo_bias : Float
  cfm_coeff : Float
  cfm_gain : Float
  writeback_id : WritebackId
}
pub fn GenericJointConstraint::invalid() -> Self

pub struct GenericJointConstraint3DReal {
  body1 : RigidBodyHandle
  body2 : RigidBodyHandle
  data : GenericJoint3DReal
}

pub struct Group {
  value : Int
}
pub fn Group::all() -> Self
pub fn Group::bits(Self) -> Int
pub fn Group::equals(Self, Self) -> Bool
pub fn Group::group_1() -> Self
pub fn Group::group_10() -> Self
pub fn Group::group_11() -> Self
pub fn Group::group_12() -> Self
pub fn Group::group_13() -> Self
pub fn Group::group_14() -> Self
pub fn Group::group_15() -> Self
pub fn Group::group_16() -> Self
pub fn Group::group_17() -> Self
pub fn Group::group_18() -> Self
pub fn Group::group_19() -> Self
pub fn Group::group_2() -> Self
pub fn Group::group_20() -> Self
pub fn Group::group_21() -> Self
pub fn Group::group_22() -> Self
pub fn Group::group_23() -> Self
pub fn Group::group_24() -> Self
pub fn Group::group_25() -> Self
pub fn Group::group_26() -> Self
pub fn Group::group_27() -> Self
pub fn Group::group_28() -> Self
pub fn Group::group_29() -> Self
pub fn Group::group_3() -> Self
pub fn Group::group_30() -> Self
pub fn Group::group_31() -> Self
pub fn Group::group_32() -> Self
pub fn Group::group_4() -> Self
pub fn Group::group_5() -> Self
pub fn Group::group_6() -> Self
pub fn Group::group_7() -> Self
pub fn Group::group_8() -> Self
pub fn Group::group_9() -> Self
pub fn Group::intersection(Self, Self) -> Self
pub fn Group::new(Int) -> Self
pub fn Group::none() -> Self
pub fn Group::or(Self, Self) -> Self

pub struct ImpulseJoint {
  body1 : RigidBodyHandle
  body2 : RigidBodyHandle
  mut data : GenericJoint
  mut impulses : @core.Vec2
  mut ang_impulse : Float
  handle : ImpulseJointHandle
}
pub fn ImpulseJoint::is_enabled(Self) -> Bool
pub fn ImpulseJoint::set_enabled(Self, Bool) -> Self
pub fn ImpulseJoint::set_enabled_by_attached_body(Self, Bool) -> Self

pub struct ImpulseJointGraph {
  nodes : Array[RigidBodyHandle]
  edges : Array[(RigidBodyHandle, RigidBodyHandle, ImpulseJoint)]
}
pub fn ImpulseJointGraph::edges(Self) -> Array[(RigidBodyHandle, RigidBodyHandle, ImpulseJoint)]
pub fn ImpulseJointGraph::nodes(Self) -> Array[RigidBodyHandle]

pub struct ImpulseJointHandle {
  id : Int
  generation : Int
}
pub fn ImpulseJointHandle::from_raw_parts(Int, Int) -> Self
pub fn ImpulseJointHandle::into_raw_parts(Self) -> (Int, Int)
pub fn ImpulseJointHandle::invalid() -> Self

type ImpulseJointSet
pub fn ImpulseJointSet::attached_enabled_joints(Self, RigidBodyHandle) -> Array[(RigidBodyHandle, RigidBodyHandle, ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::attached_joints(Self, RigidBodyHandle) -> Array[(RigidBodyHandle, RigidBodyHandle, ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::contains(Self, ImpulseJointHandle) -> Bool
pub fn ImpulseJointSet::deserialize(String) -> Self
pub fn ImpulseJointSet::get(Self, ImpulseJointHandle) -> ImpulseJoint?
pub fn ImpulseJointSet::get_mut(Self, ImpulseJointHandle, Bool) -> ImpulseJoint?
pub fn ImpulseJointSet::get_unknown_gen(Self, Int) -> (ImpulseJoint, ImpulseJointHandle)?
pub fn ImpulseJointSet::get_unknown_gen_mut(Self, Int) -> (ImpulseJoint, ImpulseJointHandle)?
pub fn ImpulseJointSet::insert(Self, RigidBodyHandle, RigidBodyHandle, GenericJoint, Bool) -> ImpulseJointHandle
pub fn ImpulseJointSet::is_empty(Self) -> Bool
pub fn ImpulseJointSet::iter(Self) -> Array[(ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::iter_mut(Self) -> Array[(ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::joint_graph(Self) -> ImpulseJointGraph
pub fn ImpulseJointSet::joints_between(Self, RigidBodyHandle, RigidBodyHandle) -> Array[(ImpulseJointHandle, ImpulseJoint)]
pub fn ImpulseJointSet::len(Self) -> Int
pub fn ImpulseJointSet::map_attached_joints_mut(Self, RigidBodyHandle, (RigidBodyHandle, RigidBodyHandle, ImpulseJointHandle, ImpulseJoint) -> Unit) -> Unit
pub fn ImpulseJointSet::new() -> Self
pub fn ImpulseJointSet::remove(Self, ImpulseJointHandle, Bool) -> ImpulseJoint?
pub fn ImpulseJointSet::remove_joints_attached_to_rigid_body(Self, RigidBodyHandle) -> Array[ImpulseJointHandle]
pub fn ImpulseJointSet::select_active_interactions(Self, IslandManager, RigidBodySet, Array[Array[Int]]) -> Unit
pub fn ImpulseJointSet::serialize(Self) -> String
pub fn ImpulseJointSet::set_enabled(Self, ImpulseJointHandle, Bool) -> Unit
pub fn ImpulseJointSet::set_impulses(Self, ImpulseJointHandle, @core.Vec2) -> Unit
pub fn ImpulseJointSet::set_solver_impulses(Self, ImpulseJointHandle, @core.Vec2, Float, Float, Float, Float, Float, Float, Float) -> Unit
pub fn ImpulseJointSet::take_to_join(Self) -> Array[(RigidBodyHandle, RigidBodyHandle)]
pub fn ImpulseJointSet::take_wake_up(Self) -> Array[RigidBodyHandle]

pub struct ImpulseJointSet3 {
  inner : ImpulseJointSet
}
pub fn ImpulseJointSet3::as_2d(Self) -> ImpulseJointSet
pub fn ImpulseJointSet3::insert(Self, RigidBodyHandle, RigidBodyHandle, GenericJoint, Bool) -> ImpulseJointHandle
pub fn ImpulseJointSet3::new() -> Self

type IndexSequence
pub fn IndexSequence::inv_rearrange_rows(Self, DVector) -> Unit
pub fn IndexSequence::keep(Self, Int) -> Unit
pub fn IndexSequence::new() -> Self
pub fn IndexSequence::rearrange_columns(Self, RowDVector, Bool) -> Unit
pub fn IndexSequence::rearrange_rows(Self, DVector, Bool) -> Unit
pub fn IndexSequence::remove(Self, Int) -> Unit
pub fn IndexSequence::with_rearranged_rows_mut(Self, DVector, (DVector) -> Unit) -> Unit

pub struct IntegrationParameters {
  mut dt : Float
  mut min_ccd_dt : Float
  mut contact_softness : SpringCoefficients
  mut warmstart_coefficient : Float
  mut length_unit : Float
  mut normalized_allowed_linear_error : Float
  mut normalized_max_corrective_velocity : Float
  mut normalized_prediction_distance : Float
  mut num_solver_iterations : Int
  mut num_internal_pgs_iterations : Int
  mut num_internal_stabilization_iterations : Int
  mut min_island_size : Int
  mut max_ccd_substeps : Int
  friction_model : FrictionModel
}
pub fn IntegrationParameters::allowed_linear_error(Self) -> Float
pub fn IntegrationParameters::default() -> Self
pub fn IntegrationParameters::inv_dt(Self) -> Float
pub fn IntegrationParameters::max_corrective_velocity(Self) -> Float
pub fn IntegrationParameters::new() -> Self
pub fn IntegrationParameters::prediction_distance(Self) -> Float
pub fn IntegrationParameters::set_contact_softness(Self, SpringCoefficients) -> Self
pub fn IntegrationParameters::set_dt(Self, Float) -> Self
pub fn IntegrationParameters::set_inv_dt(Self, Float) -> Self
pub fn IntegrationParameters::set_length_unit(Self, Float) -> Self
pub fn IntegrationParameters::set_max_ccd_substeps(Self, Int) -> Self
pub fn IntegrationParameters::set_min_ccd_dt(Self, Float) -> Self
pub fn IntegrationParameters::set_min_island_size(Self, Int) -> Self
pub fn IntegrationParameters::set_normalized_allowed_linear_error(Self, Float) -> Self
pub fn IntegrationParameters::set_normalized_max_corrective_velocity(Self, Float) -> Self
pub fn IntegrationParameters::set_normalized_prediction_distance(Self, Float) -> Self
pub fn IntegrationParameters::set_num_internal_pgs_iterations(Self, Int) -> Self
pub fn IntegrationParameters::set_num_internal_stabilization_iterations(Self, Int) -> Self
pub fn IntegrationParameters::set_num_solver_iterations(Self, Int) -> Self
pub fn IntegrationParameters::set_warmstart_coefficient(Self, Float) -> Self
pub fn IntegrationParameters::with_dt(Self, Float) -> Self

pub struct InteractionGroups {
  mut memberships : Group
  mut filter : Group
  test_mode : InteractionTestMode
}
pub fn InteractionGroups::all() -> Self
pub fn InteractionGroups::default() -> Self
pub fn InteractionGroups::filter(Self) -> Group
pub fn InteractionGroups::memberships(Self) -> Group
pub fn InteractionGroups::new(Group, Group, InteractionTestMode) -> Self
pub fn InteractionGroups::none() -> Self
pub fn InteractionGroups::test_and(Self, Self) -> Bool
pub fn InteractionGroups::test_groups(Self, Self) -> Bool
pub fn InteractionGroups::test_mode(Self) -> InteractionTestMode
pub fn InteractionGroups::test_or(Self, Self) -> Bool
pub fn InteractionGroups::with_filter(Self, Group) -> Self
pub fn InteractionGroups::with_memberships(Self, Group) -> Self

pub(all) enum InteractionTestMode {
  And
  Or
}

pub struct InverseKinematicsOption {
  mut damping : Float
  mut max_iters : Int
  mut constrained_axes : JointAxesMask
  mut epsilon_linear : Float
  mut epsilon_angular : Float
}
pub fn InverseKinematicsOption::default() -> Self
pub fn InverseKinematicsOption::set_constrained_axes(Self, JointAxesMask) -> Self
pub fn InverseKinematicsOption::set_damping(Self, Float) -> Self
pub fn InverseKinematicsOption::set_epsilon_angular(Self, Float) -> Self
pub fn InverseKinematicsOption::set_epsilon_linear(Self, Float) -> Self
pub fn InverseKinematicsOption::set_max_iters(Self, Int) -> Self

type Island

pub struct IslandManager {
  islands : Array[Island?]
  awake_islands : Array[Int]
  free_islands : Array[Int]
  traversal_candidates : Array[SleepCandidate]
  mut traversal_timestamp : Int
  optimizer : IslandsOptimizer
  stack : Array[RigidBodyHandle]
  body_island_ids : Array[Int]
  body_island_generations : Array[Int]
  body_island_indices : Array[Int]
  body_state_generations : Array[Int]
}
pub fn IslandManager::active_bodies(Self) -> Array[RigidBodyHandle]
pub fn IslandManager::active_islands(Self) -> Array[Int]
pub fn IslandManager::interaction_started_or_stopped(Self, RigidBodySet, RigidBodyHandle?, RigidBodyHandle?, Bool, Bool) -> Unit
pub fn IslandManager::island_additional_solver_iterations(Self, Int) -> Int
pub fn IslandManager::island_bodies(Self, Int) -> Array[RigidBodyHandle]
pub fn IslandManager::new() -> Self
pub fn IslandManager::rigid_body_removed_or_disabled(Self, RigidBodyHandle, RigidBodySet) -> Unit
pub fn IslandManager::rigid_body_updated(Self, RigidBodyHandle, RigidBodySet) -> Unit
pub fn IslandManager::update_islands(Self, Float, Float, RigidBodySet, ContactGraph, ImpulseJointSet, MultibodyJointSet) -> Unit
pub fn IslandManager::wake_up(Self, RigidBodySet, RigidBodyHandle, Bool) -> Unit

pub struct IslandManager3 {
  inner : IslandManager
}
pub fn IslandManager3::active_bodies(Self) -> Array[RigidBodyHandle]
pub fn IslandManager3::as_2d(Self) -> IslandManager
pub fn IslandManager3::new() -> Self

pub struct IslandManager3D {
  active_bodies : Array[RigidBodyHandle]
}
pub fn IslandManager3D::active_bodies(Self) -> Array[RigidBodyHandle]
pub fn IslandManager3D::new() -> Self
pub fn IslandManager3D::update(Self, RigidBodySet3D) -> Unit

type IslandsOptimizer

type Jacobian
pub fn Jacobian::cols(Self) -> Int
pub fn Jacobian::equals(Self, Self) -> Bool
pub fn Jacobian::spatial_dim() -> Int
pub fn Jacobian::value_at(Self, Int, Int) -> Float
pub fn Jacobian::zeros(Int) -> Self

pub struct Jacobian3 {
  inner : Jacobian
}
pub fn Jacobian3::cols(Self) -> Int
pub fn Jacobian3::value_at(Self, Int, Int) -> Float
pub fn Jacobian3::zeros(Int) -> Self

pub struct JointAxesMask {
  bits : Int
}
pub fn JointAxesMask::all() -> Self
pub fn JointAxesMask::ang_axes() -> Self
pub fn JointAxesMask::ang_x() -> Self
pub fn JointAxesMask::ang_z() -> Self
pub fn JointAxesMask::bits(Self) -> Int
pub fn JointAxesMask::contains(Self, Self) -> Bool
pub fn JointAxesMask::empty() -> Self
pub fn JointAxesMask::free_fixed_axes() -> Self
pub fn JointAxesMask::free_prismatic_axes() -> Self
pub fn JointAxesMask::free_revolute_axes() -> Self
pub fn JointAxesMask::intersection(Self, Self) -> Self
pub fn JointAxesMask::lin_axes() -> Self
pub fn JointAxesMask::lin_x() -> Self
pub fn JointAxesMask::lin_y() -> Self
pub fn JointAxesMask::locked_fixed_axes() -> Self
pub fn JointAxesMask::locked_pin_slot_axes() -> Self
pub fn JointAxesMask::locked_prismatic_axes() -> Self
pub fn JointAxesMask::locked_revolute_axes() -> Self
pub fn JointAxesMask::new(Int) -> Self
pub fn JointAxesMask::or(Self, Self) -> Self

pub struct JointAxesMask3DReal {
  bits : Int
}
pub fn JointAxesMask3DReal::all() -> Self
pub fn JointAxesMask3DReal::ang_axes() -> Self
pub fn JointAxesMask3DReal::ang_x() -> Self
pub fn JointAxesMask3DReal::ang_y() -> Self
pub fn JointAxesMask3DReal::ang_z() -> Self
pub fn JointAxesMask3DReal::bits(Self) -> Int
pub fn JointAxesMask3DReal::contains(Self, Self) -> Bool
pub fn JointAxesMask3DReal::empty() -> Self
pub fn JointAxesMask3DReal::free_fixed_axes() -> Self
pub fn JointAxesMask3DReal::free_prismatic_axes() -> Self
pub fn JointAxesMask3DReal::free_revolute_axes() -> Self
pub fn JointAxesMask3DReal::free_spherical_axes() -> Self
pub fn JointAxesMask3DReal::intersection(Self, Self) -> Self
pub fn JointAxesMask3DReal::lin_axes() -> Self
pub fn JointAxesMask3DReal::lin_x() -> Self
pub fn JointAxesMask3DReal::lin_y() -> Self
pub fn JointAxesMask3DReal::lin_z() -> Self
pub fn JointAxesMask3DReal::locked_fixed_axes() -> Self
pub fn JointAxesMask3DReal::locked_prismatic_axes() -> Self
pub fn JointAxesMask3DReal::locked_revolute_axes() -> Self
pub fn JointAxesMask3DReal::locked_spherical_axes() -> Self
pub fn JointAxesMask3DReal::new(Int) -> Self
pub fn JointAxesMask3DReal::or(Self, Self) -> Self

pub(all) enum JointAxis {
  LinX
  LinY
  AngZ
}

pub(all) enum JointAxis3DReal {
  LinX
  LinY
  LinZ
  AngX
  AngY
  AngZ
}

pub(all) enum JointEnabled {
  Enabled
  DisabledByAttachedBody
  Disabled
}

pub struct JointHandle3DReal {
  index : Int
}

pub struct JointLimits {
  min : Float
  max : Float
  mut impulse : Float
}
pub fn JointLimits::clear_impulse(Self) -> Self
pub fn JointLimits::default() -> Self
pub fn JointLimits::impulse(Self) -> Float
pub fn JointLimits::max(Self) -> Float
pub fn JointLimits::min(Self) -> Float
pub fn JointLimits::new(Float, Float) -> Self
pub fn JointLimits::set_impulse(Self, Float) -> Self
pub fn JointLimits::set_max(Self, Float) -> Self
pub fn JointLimits::set_min(Self, Float) -> Self

pub struct JointLimits3 {
  lin_x : JointLimits
  lin_y : JointLimits
  ang_z : JointLimits
}
pub fn JointLimits3::default() -> Self

pub struct JointMotor {
  target_vel : Float
  target_pos : Float
  stiffness : Float
  damping : Float
  max_force : Float
  mut impulse : Float
  model : MotorModel
}
pub fn JointMotor::clear_impulse(Self) -> Self
pub fn JointMotor::default() -> Self
pub fn JointMotor::impulse(Self) -> Float
pub fn JointMotor::set_damping(Self, Float) -> Self
pub fn JointMotor::set_impulse(Self, Float) -> Self
pub fn JointMotor::set_max_force(Self, Float) -> Self
pub fn JointMotor::set_model(Self, MotorModel) -> Self
pub fn JointMotor::set_stiffness(Self, Float) -> Self
pub fn JointMotor::set_target_pos(Self, Float) -> Self
pub fn JointMotor::set_target_vel(Self, Float) -> Self

pub struct JointMotors3 {
  lin_x : JointMotor
  lin_y : JointMotor
  ang_z : JointMotor
}
pub fn JointMotors3::default() -> Self

pub struct JointSet3DReal {
  spherical : Array[SphericalJoint3DReal]
  prismatic : Array[PrismaticJoint3DReal]
  spherical_motors : Array[SphericalMotor3DReal]
  generic : Array[GenericJointConstraint3DReal]
  springs : Array[SpringJoint3DReal]
}
pub fn JointSet3DReal::disabled_contact_pairs(Self) -> Array[(RigidBodyHandle, RigidBodyHandle)]
pub fn JointSet3DReal::insert_generic(Self, RigidBodyHandle, RigidBodyHandle, GenericJoint3DReal, Bool) -> JointHandle3DReal
pub fn JointSet3DReal::insert_prismatic_motor_position(Self, RigidBodyHandle, RigidBodyHandle, @core.Vec3, @core.Vec3, @core.Vec3, Float, Float, Float) -> Unit
pub fn JointSet3DReal::insert_revolute(Self, RigidBodyHandle, RigidBodyHandle, @core.Vec3, @core.Vec3, @core.Vec3, Bool) -> JointHandle3DReal
pub fn JointSet3DReal::insert_spherical(Self, RigidBodyHandle, RigidBodyHandle, @core.Vec3, @core.Vec3) -> Unit
pub fn JointSet3DReal::insert_spherical_motor_rotation(Self, RigidBodyHandle, RigidBodyHandle, @core.Quat, Float, Float) -> Unit
pub fn JointSet3DReal::insert_spring(Self, RigidBodyHandle, RigidBodyHandle, @core.Vec3, @core.Vec3, Float, Float, Float, Bool) -> Unit
pub fn JointSet3DReal::new() -> Self
pub fn JointSet3DReal::set_motor_position(Self, JointHandle3DReal, JointAxis3DReal, Float, Float, Float, Float) -> Unit
pub fn JointSet3DReal::set_motor_velocity(Self, JointHandle3DReal, JointAxis3DReal, Float, Float, Float) -> Unit
pub fn JointSet3DReal::solve(Self, RigidBodySet3D, Float) -> Unit

pub struct JointSolverBody {
  im : @core.Vec2
  ii : Float
  world_com : @core.Vec2
  solver_vel : Int
}
pub fn JointSolverBody::invalid() -> Self

pub struct LinkId {
  value : Int
}

pub(all) enum LinkOrBodyRef {
  Link(MultibodyLinkId)
  Body(Int)
  Fixed
}

pub struct LockedAxes {
  bits : Int
}
pub fn LockedAxes::bits(Self) -> Int
pub fn LockedAxes::contains(Self, Self) -> Bool
pub fn LockedAxes::empty() -> Self
pub fn LockedAxes::insert(Self, Self) -> Self
pub fn LockedAxes::new(Int) -> Self
pub fn LockedAxes::remove(Self, Self) -> Self
pub fn LockedAxes::rotation_locked() -> Self
pub fn LockedAxes::rotation_locked_x() -> Self
pub fn LockedAxes::rotation_locked_y() -> Self
pub fn LockedAxes::rotation_locked_z() -> Self
pub fn LockedAxes::translation_locked() -> Self
pub fn LockedAxes::translation_locked_x() -> Self
pub fn LockedAxes::translation_locked_y() -> Self
pub fn LockedAxes::translation_locked_z() -> Self

pub(all) enum MotorModel {
  AccelerationBased
  ForceBased
}
pub fn MotorModel::combine_coefficients(Self, Float, Float, Float) -> (Float, Float, Float)

pub(all) enum MotorState3DReal {
  Disabled
  Velocity(Float, Float, Float)
  Position(Float, Float, Float, Float)
}

type Multibody
pub fn Multibody::apply_displacements(Self, Array[Float]) -> Unit
pub fn Multibody::body_jacobian(Self, LinkId) -> Jacobian
pub fn Multibody::damping_mut(Self) -> DVector
pub fn Multibody::forward_kinematics(Self, RigidBodySet, Bool) -> Unit
pub fn Multibody::forward_kinematics_single_branch(Self, RigidBodySet, Array[Int], Array[Float]?, Jacobian?) -> @core.Isometry2
pub fn Multibody::forward_kinematics_single_link(Self, RigidBodySet, LinkId, Array[Float]?, Jacobian?) -> @core.Isometry2
pub fn Multibody::generalized_acceleration(Self) -> DVector
pub fn Multibody::generalized_velocity(Self) -> DVector
pub fn Multibody::generalized_velocity_mut(Self) -> DVector
pub fn Multibody::inv_augmented_mass(Self) -> @core.DMatrix
pub fn Multibody::inverse_kinematics(Self, RigidBodySet, LinkId, InverseKinematicsOption, @core.Isometry2, (MultibodyLink) -> Bool, DVector) -> Unit
pub fn Multibody::inverse_kinematics_delta(Self, LinkId, Float, Float, Float, Float, DVector) -> Unit
pub fn Multibody::inverse_kinematics_delta_with_jacobian(Jacobian, Float, Float, Float, Float, DVector) -> Unit
pub fn Multibody::joint_velocity(Self, MultibodyLink) -> DVector
pub fn Multibody::kinematic_branch(Self, Int) -> Array[Int]
pub fn Multibody::link(Self, LinkId) -> MultibodyLink?
pub fn Multibody::link_mut(Self, LinkId) -> MultibodyLink?
pub fn Multibody::links_mut(Self) -> Array[MultibodyLink]
pub fn Multibody::ndofs(Self) -> Int
pub fn Multibody::num_links(Self) -> Int
pub fn Multibody::root(Self) -> MultibodyLink?
pub fn Multibody::root_mut(Self) -> MultibodyLink?
pub fn Multibody::self_contacts_enabled(Self) -> Bool
pub fn Multibody::set_self_contacts_enabled(Self, Bool) -> Unit
pub fn Multibody::update_rigid_bodies(Self, RigidBodySet) -> Unit

pub struct Multibody3 {
  inner : Multibody
}
pub fn Multibody3::apply_displacements(Self, Array[Float]) -> Unit
pub fn Multibody3::body_jacobian(Self, LinkId) -> Jacobian3
pub fn Multibody3::forward_kinematics(Self, RigidBodySet3, Bool) -> Unit
pub fn Multibody3::forward_kinematics_single_link(Self, RigidBodySet3, LinkId, Array[Float]?, Jacobian3?) -> @core.Isometry3
pub fn Multibody3::inverse_kinematics(Self, RigidBodySet3, LinkId, InverseKinematicsOption, @core.Isometry3, (MultibodyLink) -> Bool, DVector) -> Unit
pub fn Multibody3::link_pose(Self, LinkId) -> @core.Isometry3?
pub fn Multibody3::ndofs(Self) -> Int

pub struct MultibodyIndex {
  value : Int
}
pub fn MultibodyIndex::invalid() -> Self

pub struct MultibodyJoint {
  data : GenericJoint
  kinematic : Bool
  mut coords : @core.Vec2
  mut angle : Float
  mut joint_rot : @core.Rot2
}
pub fn MultibodyJoint::apply_displacement(Self, Array[Float]) -> Unit
pub fn MultibodyJoint::body_to_parent(Self) -> @core.Isometry2
pub fn MultibodyJoint::default_damping(Self, DVector) -> Unit
pub fn MultibodyJoint::jacobian(Self, @core.Rot2, Jacobian) -> Unit
pub fn MultibodyJoint::jacobian_mul_coordinates(Self, Array[Float]) -> RigidBodyVelocity
pub fn MultibodyJoint::new(GenericJoint, Bool) -> Self
pub fn MultibodyJoint::num_velocity_constraints(Self) -> Int
pub fn MultibodyJoint::velocity_constraints(Self, IntegrationParameters, Multibody, MultibodyLink, Int, DVector, Array[GenericJointConstraint]) -> Int

type MultibodyJointHandle
pub fn MultibodyJointHandle::from_raw_parts(Int, Int) -> Self
pub fn MultibodyJointHandle::into_raw_parts(Self) -> (Int, Int)
pub fn MultibodyJointHandle::invalid() -> Self

type MultibodyJointSet
pub fn MultibodyJointSet::attached_bodies(Self, RigidBodyHandle) -> Array[RigidBodyHandle]
pub fn MultibodyJointSet::attached_joints(Self, RigidBodyHandle) -> Array[(RigidBodyHandle, RigidBodyHandle, MultibodyJointHandle)]
pub fn MultibodyJointSet::bodies_attached_with_enabled_joint(Self, RigidBodyHandle) -> Array[RigidBodyHandle]
pub fn MultibodyJointSet::deserialize(String) -> Self
pub fn MultibodyJointSet::get(Self, MultibodyJointHandle) -> (Multibody, LinkId)?
pub fn MultibodyJointSet::get_multibody(Self, MultibodyIndex) -> Multibody?
pub fn MultibodyJointSet::get_multibody_mut(Self, MultibodyIndex) -> Multibody?
pub fn MultibodyJointSet::get_multibody_mut_internal(Self, MultibodyIndex) -> Multibody?
pub fn MultibodyJointSet::get_mut(Self, MultibodyJointHandle) -> (Multibody, LinkId)?
pub fn MultibodyJointSet::get_mut_internal(Self, MultibodyJointHandle) -> (Multibody, LinkId)?
pub fn MultibodyJointSet::get_unknown_gen(Self, Int) -> (Multibody, LinkId, MultibodyJointHandle)?
pub fn MultibodyJointSet::insert(Self, RigidBodyHandle, RigidBodyHandle, RevoluteJoint, Bool) -> MultibodyJointHandle?
pub fn MultibodyJointSet::insert_kinematic(Self, RigidBodyHandle, RigidBodyHandle, RevoluteJoint, Bool) -> MultibodyJointHandle?
pub fn MultibodyJointSet::iter(Self) -> Array[(MultibodyJointHandle, MultibodyLinkId, Multibody, MultibodyLink)]
pub fn MultibodyJointSet::joint_between(Self, RigidBodyHandle, RigidBodyHandle) -> (MultibodyJointHandle, Multibody, MultibodyLink)?
pub fn MultibodyJointSet::multibodies(Self) -> Array[Multibody]
pub fn MultibodyJointSet::new() -> Self
pub fn MultibodyJointSet::remove(Self, MultibodyJointHandle, Bool) -> Unit
pub fn MultibodyJointSet::remove_multibody_articulations(Self, RigidBodyHandle, Bool) -> Unit
pub fn MultibodyJointSet::revolute_joint_descriptors(Self) -> Array[MultibodyRevoluteJointDesc]
pub fn MultibodyJointSet::rigid_body_link(Self, RigidBodyHandle) -> MultibodyLinkId?
pub fn MultibodyJointSet::serialize(Self) -> String
pub fn MultibodyJointSet::set_revolute_joint_solver_impulses(Self, MultibodyLinkId, @core.Vec2, Float, Float) -> Unit
pub fn MultibodyJointSet::sync_rigid_bodies_from_multibodies(Self, RigidBodySet) -> Unit
pub fn MultibodyJointSet::take_to_join(Self) -> Array[(RigidBodyHandle, RigidBodyHandle)]
pub fn MultibodyJointSet::take_wake_up(Self) -> Array[RigidBodyHandle]

pub struct MultibodyJointSet3 {
  inner : MultibodyJointSet
}
pub fn MultibodyJointSet3::as_2d(Self) -> MultibodyJointSet
pub fn MultibodyJointSet3::get(Self, MultibodyJointHandle) -> (Multibody3, LinkId)?
pub fn MultibodyJointSet3::get_mut(Self, MultibodyJointHandle) -> (Multibody3, LinkId)?
pub fn MultibodyJointSet3::insert(Self, RigidBodyHandle, RigidBodyHandle, RevoluteJoint, Bool) -> MultibodyJointHandle?
pub fn MultibodyJointSet3::new() -> Self

type MultibodyLink
pub fn MultibodyLink::is_root(Self) -> Bool
pub fn MultibodyLink::link_id(Self) -> LinkId
pub fn MultibodyLink::local_to_parent(Self) -> @core.Isometry2
pub fn MultibodyLink::local_to_world(Self) -> @core.Isometry2
pub fn MultibodyLink::parent_id(Self) -> LinkId
pub fn MultibodyLink::rigid_body_handle(Self) -> RigidBodyHandle

pub struct MultibodyLinkId {
  multibody : MultibodyIndex
  id : Int
}

pub struct MultibodyRevoluteJointDesc {
  link : MultibodyLinkId
  parent : RigidBodyHandle
  child : RigidBodyHandle
  joint : RevoluteJoint
  solver_lin_impulses : @core.Vec2
}

pub struct PdErrors3 {
  linear : @core.Vec3
  angular : @core.Vec3
}

pub struct PinSlotJoint {
  axis : @core.Vec2
  local_anchor1 : @core.Vec2
  local_anchor2 : @core.Vec2
  limits : JointLimits
  limits_enabled : Bool
}
pub fn PinSlotJoint::set_local_axis1(Self, @core.Vec2) -> Self
pub fn PinSlotJoint::set_local_axis2(Self, @core.Vec2) -> Self

pub struct PinSlotJointBuilder {
  axis : @core.Vec2
  mut local_anchor1 : @core.Vec2
  mut local_anchor2 : @core.Vec2
  mut limits : JointLimits
  mut limits_enabled : Bool
}
pub fn PinSlotJointBuilder::build(Self) -> PinSlotJoint
pub fn PinSlotJointBuilder::limits(Self, Float, Float) -> Self
pub fn PinSlotJointBuilder::local_anchor1(Self, @core.Vec2) -> Self
pub fn PinSlotJointBuilder::local_anchor2(Self, @core.Vec2) -> Self
pub fn PinSlotJointBuilder::new(@core.Vec2) -> Self

pub(all) enum PredictedImpacts {
  Impacts(Array[(RigidBodyHandle, Float)])
  ImpactsAfterEndTime(Float)
  NoImpacts
}

pub struct PrismaticJoint {
  axis : @core.Vec2
  local_anchor1 : @core.Vec2
  local_anchor2 : @core.Vec2
  limits : JointLimits
  limits_enabled : Bool
}
pub fn PrismaticJoint::set_local_axis1(Self, @core.Vec2) -> Self
pub fn PrismaticJoint::set_local_axis2(Self, @core.Vec2) -> Self

pub struct PrismaticJoint3DReal {
  body1 : RigidBodyHandle
  body2 : RigidBodyHandle
  local_anchor1 : @core.Vec3
  local_anchor2 : @core.Vec3
  local_axis1 : @core.Vec3
  motor_target : Float
  motor_stiffness : Float
  motor_damping : Float
  motor_enabled : Bool
}

pub struct PrismaticJoint3DRealBuilder {
  inner : GenericJoint3DRealBuilder
}
pub fn PrismaticJoint3DRealBuilder::build(Self) -> GenericJoint3DReal
pub fn PrismaticJoint3DRealBuilder::limits(Self, Float, Float) -> Self
pub fn PrismaticJoint3DRealBuilder::local_anchor1(Self, @core.Vec3) -> Self
pub fn PrismaticJoint3DRealBuilder::local_anchor2(Self, @core.Vec3) -> Self
pub fn PrismaticJoint3DRealBuilder::motor_max_force(Self, Float) -> Self
pub fn PrismaticJoint3DRealBuilder::motor_position(Self, Float, Float, Float) -> Self
pub fn PrismaticJoint3DRealBuilder::motor_velocity(Self, Float, Float) -> Self
pub fn PrismaticJoint3DRealBuilder::new(@core.Vec3) -> Self

type PrismaticJointBuilder
pub fn PrismaticJointBuilder::build(Self) -> PrismaticJoint
pub fn PrismaticJointBuilder::limits(Self, Float, Float) -> Self
pub fn PrismaticJointBuilder::local_anchor1(Self, @core.Vec2) -> Self
pub fn PrismaticJointBuilder::local_anchor2(Self, @core.Vec2) -> Self
pub fn PrismaticJointBuilder::new(@core.Vec2) -> Self

pub struct PrismaticJointBuilder3 {
  inner : PrismaticJointBuilder
}
pub fn PrismaticJointBuilder3::build(Self) -> PrismaticJoint
pub fn PrismaticJointBuilder3::limits(Self, Float, Float) -> Self
pub fn PrismaticJointBuilder3::local_anchor1(Self, @core.Vec3) -> Self
pub fn PrismaticJointBuilder3::local_anchor2(Self, @core.Vec3) -> Self
pub fn PrismaticJointBuilder3::new(@core.Vec3) -> Self

type RevoluteJoint
pub fn RevoluteJoint::angle(Self, @core.Rot2, @core.Rot2) -> Float
pub fn RevoluteJoint::limits(Self) -> JointLimits?
pub fn RevoluteJoint::local_anchor1(Self) -> @core.Vec2
pub fn RevoluteJoint::local_anchor2(Self) -> @core.Vec2
pub fn RevoluteJoint::motor(Self) -> JointMotor?
pub fn RevoluteJoint::softness(Self) -> SpringCoefficients

pub struct RevoluteJoint3 {
  axis : @core.Vec3
  local_frame1_rotation : @core.Quat
  local_frame2_rotation : @core.Quat
}
pub fn RevoluteJoint3::angle(Self, @core.Quat, @core.Quat) -> Float
pub fn RevoluteJoint3::new(@core.Vec3) -> Self

pub struct RevoluteJoint3Builder(RevoluteJoint3)
pub fn RevoluteJoint3Builder::build(Self) -> RevoluteJoint3
#deprecated
pub fn RevoluteJoint3Builder::inner(Self) -> RevoluteJoint3
pub fn RevoluteJoint3Builder::new(@core.Vec3) -> Self

pub struct RevoluteJoint3DRealBuilder {
  inner : GenericJoint3DRealBuilder
}
pub fn RevoluteJoint3DRealBuilder::build(Self) -> GenericJoint3DReal
pub fn RevoluteJoint3DRealBuilder::limits(Self, Float, Float) -> Self
pub fn RevoluteJoint3DRealBuilder::local_anchor1(Self, @core.Vec3) -> Self
pub fn RevoluteJoint3DRealBuilder::local_anchor2(Self, @core.Vec3) -> Self
pub fn RevoluteJoint3DRealBuilder::motor_max_force(Self, Float) -> Self
pub fn RevoluteJoint3DRealBuilder::motor_position(Self, Float, Float, Float) -> Self
pub fn RevoluteJoint3DRealBuilder::motor_velocity(Self, Float, Float) -> Self
pub fn RevoluteJoint3DRealBuilder::new(@core.Vec3) -> Self

type RevoluteJointBuilder
pub fn RevoluteJointBuilder::build(Self) -> RevoluteJoint
pub fn RevoluteJointBuilder::limits(Self, Float, Float) -> Self
pub fn RevoluteJointBuilder::local_anchor1(Self, @core.Vec2) -> Self
pub fn RevoluteJointBuilder::local_anchor2(Self, @core.Vec2) -> Self
pub fn RevoluteJointBuilder::motor_max_force(Self, Float) -> Self
pub fn RevoluteJointBuilder::motor_model(Self, MotorModel) -> Self
pub fn RevoluteJointBuilder::motor_position(Self, Float, Float, Float) -> Self
pub fn RevoluteJointBuilder::motor_velocity(Self, Float, Float) -> Self
pub fn RevoluteJointBuilder::new() -> Self
pub fn RevoluteJointBuilder::softness(Self, SpringCoefficients) -> Self

pub struct RevoluteJointBuilder3 {
  inner : RevoluteJointBuilder
}
pub fn RevoluteJointBuilder3::build(Self) -> RevoluteJoint
pub fn RevoluteJointBuilder3::limits(Self, Float, Float) -> Self
pub fn RevoluteJointBuilder3::local_anchor1(Self, @core.Vec3) -> Self
pub fn RevoluteJointBuilder3::local_anchor2(Self, @core.Vec3) -> Self
pub fn RevoluteJointBuilder3::motor_max_force(Self, Float) -> Self
pub fn RevoluteJointBuilder3::motor_position(Self, Float, Float, Float) -> Self
pub fn RevoluteJointBuilder3::motor_velocity(Self, Float, Float) -> Self
pub fn RevoluteJointBuilder3::new(@core.Vec3) -> Self
pub fn RevoluteJointBuilder3::softness(Self, SpringCoefficients) -> Self

pub struct RigidBody {
  mut ids : RigidBodyIds
  position : RigidBodyPosition
  mut body_type : RigidBodyType
  mut locked_translations : Bool
  mut locked_rotations : Bool
  dominance : RigidBodyDominance
  mut enabled : Bool
  mut activation : RigidBodyActivation
  mut damping : RigidBodyDamping
  mut vels : RigidBodyVelocity
  mut forces : RigidBodyForces
  mut ccd : RigidBodyCcd
  mut mass_props : RigidBodyMassProps
  mut additional_mass : Float
  mut additional_solver_iterations : Int
  mut changes : RigidBodyChanges
}
pub fn RigidBody::activation(Self) -> RigidBodyActivation
pub fn RigidBody::activation_mut(Self) -> RigidBodyActivation
pub fn RigidBody::active_island_id(Self) -> Int
pub fn RigidBody::add_force(Self, @core.Vec2, Bool) -> Self
pub fn RigidBody::add_force_at_point(Self, @core.Vec2, @core.Vec2, Bool) -> Self
pub fn RigidBody::add_torque(Self, Float, Bool) -> Self
pub fn RigidBody::additional_mass(Self) -> Float
pub fn RigidBody::additional_solver_iterations(Self) -> Int
pub fn RigidBody::angular_damping(Self) -> Float
pub fn RigidBody::angvel(Self) -> Float
pub fn RigidBody::angvel_with_gyroscopic_forces(Self, Float) -> Float
pub fn RigidBody::apply_impulse(Self, @core.Vec2, Bool) -> Self
pub fn RigidBody::apply_impulse_at_point(Self, @core.Vec2, @core.Vec2, Bool) -> Self
pub fn RigidBody::apply_torque_impulse(Self, Float, Bool) -> Self
pub fn RigidBody::body_type(Self) -> RigidBodyType
pub fn RigidBody::ccd(Self) -> RigidBodyCcd
pub fn RigidBody::center_of_mass(Self) -> @core.Vec2
pub fn RigidBody::clear_changes(Self) -> Self
pub fn RigidBody::damping(Self) -> RigidBodyDamping
pub fn RigidBody::dominance_group(Self) -> Int
pub fn RigidBody::effective_active_set_offset(Self) -> Int
pub fn RigidBody::effective_dominance_group(Self) -> Int
pub fn RigidBody::enable_ccd(Self, Bool) -> Self
pub fn RigidBody::enable_gyroscopic_forces(Self, Bool) -> Self
pub fn RigidBody::forces(Self) -> RigidBodyForces
pub fn RigidBody::gravitational_potential_energy(Self, Float, @core.Vec2) -> Float
pub fn RigidBody::gravity_scale(Self) -> Float
pub fn RigidBody::inertia(Self) -> Float
pub fn RigidBody::inv_inertia(Self) -> Float
pub fn RigidBody::inv_mass(Self) -> Float
pub fn RigidBody::is_ccd_active(Self) -> Bool
pub fn RigidBody::is_ccd_enabled(Self) -> Bool
pub fn RigidBody::is_dynamic(Self) -> Bool
pub fn RigidBody::is_dynamic_or_kinematic(Self) -> Bool
pub fn RigidBody::is_enabled(Self) -> Bool
pub fn RigidBody::is_fixed(Self) -> Bool
pub fn RigidBody::is_kinematic(Self) -> Bool
pub fn RigidBody::is_moving(Self) -> Bool
pub fn RigidBody::is_rotation_locked(Self) -> Bool
pub fn RigidBody::is_sleeping(Self) -> Bool
pub fn RigidBody::is_translation_locked(Self) -> Bool
pub fn RigidBody::kinetic_energy(Self) -> Float
pub fn RigidBody::linear_damping(Self) -> Float
pub fn RigidBody::linvel(Self) -> @core.Vec2
pub fn RigidBody::local_center_of_mass(Self) -> @core.Vec2
pub fn RigidBody::lock_rotations(Self) -> Self
pub fn RigidBody::lock_translations(Self) -> Self
pub fn RigidBody::locked_rotations(Self) -> Bool
pub fn RigidBody::locked_translations(Self) -> Bool
pub fn RigidBody::mark_local_mass_properties_changed(Self) -> Self
pub fn RigidBody::mass(Self) -> Float
pub fn RigidBody::mass_props(Self) -> RigidBodyMassProps
pub fn RigidBody::next_position(Self) -> @core.Isometry2
pub fn RigidBody::position(Self) -> @core.Isometry2
pub fn RigidBody::predict_position_using_velocity(Self, Float) -> @core.Isometry2
pub fn RigidBody::predict_position_using_velocity_and_forces(Self, Float) -> @core.Isometry2
pub fn RigidBody::recompute_mass_properties_from_colliders(Self) -> Self
pub fn RigidBody::reset_forces(Self, Bool) -> Self
pub fn RigidBody::reset_torques(Self, Bool) -> Self
pub fn RigidBody::restrict_rotations(Self, Bool, Bool, Bool, Bool) -> Self
pub fn RigidBody::restrict_translations(Self, Bool, Bool, Bool, Bool) -> Self
pub fn RigidBody::rotation(Self) -> @core.Rot2
pub fn RigidBody::set_additional_mass(Self, Float, Bool) -> Self
pub fn RigidBody::set_additional_mass_properties(Self, RigidBodyAdditionalMassProps, Bool) -> Self
pub fn RigidBody::set_additional_solver_iterations(Self, Int) -> Self
pub fn RigidBody::set_angular_damping(Self, Float) -> Self
pub fn RigidBody::set_angvel(Self, Float, Bool) -> Self
pub fn RigidBody::set_body_type(Self, RigidBodyType, Bool) -> Self
pub fn RigidBody::set_ccd_properties(Self, Float, Float) -> Self
pub fn RigidBody::set_dominance_group(Self, Int) -> Self
pub fn RigidBody::set_enabled(Self, Bool) -> Self
pub fn RigidBody::set_enabled_rotations(Self, Bool, Bool, Bool, Bool) -> Self
pub fn RigidBody::set_enabled_translations(Self, Bool, Bool, Bool, Bool) -> Self
pub fn RigidBody::set_gravity_scale(Self, Float, Bool) -> Self
pub fn RigidBody::set_kinematic_position_based_vels(Self, RigidBodyVelocity) -> Self
pub fn RigidBody::set_linear_damping(Self, Float) -> Self
pub fn RigidBody::set_linvel(Self, @core.Vec2, Bool) -> Self
pub fn RigidBody::set_local_mass_properties(Self, @core.MassProperties) -> Self
pub fn RigidBody::set_locked_rotations(Self, Bool, Bool) -> Self
pub fn RigidBody::set_locked_translations(Self, Bool, Bool) -> Self
pub fn RigidBody::set_next_kinematic_position(Self, @core.Isometry2) -> Self
pub fn RigidBody::set_next_kinematic_rotation(Self, @core.Rot2) -> Self
pub fn RigidBody::set_next_kinematic_translation(Self, @core.Vec2) -> Self
pub fn RigidBody::set_next_position_internal(Self, @core.Isometry2) -> Self
pub fn RigidBody::set_position(Self, @core.Isometry2, Bool) -> Self
pub fn RigidBody::set_rotation(Self, @core.Rot2, Bool) -> Self
pub fn RigidBody::set_soft_ccd_prediction(Self, Float) -> Self
pub fn RigidBody::set_translation(Self, @core.Vec2, Bool) -> Self
pub fn RigidBody::set_vels(Self, RigidBodyVelocity, Bool) -> Self
pub fn RigidBody::sleep(Self) -> Self
pub fn RigidBody::soft_ccd_prediction(Self) -> Float
pub fn RigidBody::translation(Self) -> @core.Vec2
pub fn RigidBody::update_effective_force_and_torque(Self, @core.Vec2) -> Self
pub fn RigidBody::velocity_at_point(Self, @core.Vec2) -> @core.Vec2
pub fn RigidBody::vels(Self) -> RigidBodyVelocity
pub fn RigidBody::wake_up(Self, Bool) -> Self
pub fn RigidBody::world_com(Self) -> @core.Vec2

pub struct RigidBody3D {
  body_type : RigidBodyType
  mut position : @core.Isometry3
  mut next_position : @core.Isometry3
  mut velocity : RigidBodyVelocity3D
  locked_translations : Bool
  locked_rotations : Bool
  rot_x_enabled : Bool
  rot_y_enabled : Bool
  rot_z_enabled : Bool
  ccd_enabled : Bool
  soft_ccd_prediction : Float
  gyroscopic_forces_enabled : Bool
  linear_damping : Float
  angular_damping : Float
  mut gravity_scale : Float
  mass_properties : @core.MassProperties3
  mut activation : RigidBodyActivation3D
  can_sleep : Bool
}
pub fn RigidBody3D::advance_position(Self, Float) -> Unit
pub fn RigidBody3D::angvel(Self) -> @core.Vec3
pub fn RigidBody3D::apply_damping(Self, Float) -> Unit
pub fn RigidBody3D::apply_gravity(Self, @core.Vec3, Float) -> Unit
pub fn RigidBody3D::apply_gyroscopic_forces(Self, Float) -> Unit
pub fn RigidBody3D::apply_impulse_at_point(Self, @core.Vec3, @core.Vec3, Bool) -> Unit
pub fn RigidBody3D::body_type(Self) -> RigidBodyType
pub fn RigidBody3D::gravity_scale(Self) -> Float
pub fn RigidBody3D::gyroscopic_forces_enabled(Self) -> Bool
pub fn RigidBody3D::integrate(Self, @core.Vec3, Float) -> Unit
pub fn RigidBody3D::is_active(Self) -> Bool
pub fn RigidBody3D::is_ccd_active(Self) -> Bool
pub fn RigidBody3D::is_sleeping(Self) -> Bool
pub fn RigidBody3D::linvel(Self) -> @core.Vec3
pub fn RigidBody3D::locked_rotations(Self) -> Bool
pub fn RigidBody3D::locked_translations(Self) -> Bool
pub fn RigidBody3D::mass_properties(Self) -> @core.MassProperties3
pub fn RigidBody3D::next_position(Self) -> @core.Isometry3
pub fn RigidBody3D::position(Self) -> @core.Isometry3
pub fn RigidBody3D::rotation(Self) -> @core.Quat
pub fn RigidBody3D::set_angvel(Self, @core.Vec3) -> Unit
pub fn RigidBody3D::set_gravity_scale(Self, Float, Bool) -> Unit
pub fn RigidBody3D::set_linvel(Self, @core.Vec3) -> Unit
pub fn RigidBody3D::set_next_kinematic_rotation(Self, @core.Quat) -> Unit
pub fn RigidBody3D::set_next_kinematic_translation(Self, @core.Vec3) -> Unit
pub fn RigidBody3D::set_rotation(Self, @core.Quat) -> Unit
pub fn RigidBody3D::set_translation(Self, @core.Vec3) -> Unit
pub fn RigidBody3D::soft_ccd_prediction(Self) -> Float
pub fn RigidBody3D::translation(Self) -> @core.Vec3
pub fn RigidBody3D::update_kinematic_velocities(Self, Float) -> Unit
pub fn RigidBody3D::update_sleep(Self, Float, Float) -> Unit
pub fn RigidBody3D::wake_up(Self) -> Unit
pub fn RigidBody3D::world_com(Self) -> @core.Vec3

pub struct RigidBodyActivation {
  mut normalized_linear_threshold : Float
  mut angular_threshold : Float
  mut time_until_sleep : Float
  mut time_since_can_sleep : Float
  mut sleeping : Bool
  mut sleep_root_state : SleepRootState
}
pub fn RigidBodyActivation::active() -> Self
pub fn RigidBodyActivation::cannot_sleep() -> Self
pub fn RigidBodyActivation::default() -> Self
pub fn RigidBodyActivation::default_angular_threshold() -> Float
pub fn RigidBodyActivation::default_normalized_linear_threshold() -> Float
pub fn RigidBodyActivation::default_time_until_sleep() -> Float
pub fn RigidBodyActivation::inactive() -> Self
pub fn RigidBodyActivation::is_active(Self) -> Bool
pub fn RigidBodyActivation::is_eligible_for_sleep(Self) -> Bool
pub fn RigidBodyActivation::sleep(Self) -> Self
pub fn RigidBodyActivation::update_energy(Self, RigidBodyType, Float, Float, Float, Float) -> Self
pub fn RigidBodyActivation::wake_up(Self, Bool) -> Self

pub struct RigidBodyActivation3D {
  normalized_linear_threshold : Float
  angular_threshold : Float
  time_until_sleep : Float
  mut time_since_can_sleep : Float
  mut sleeping : Bool
}
pub fn RigidBodyActivation3D::active() -> Self
pub fn RigidBodyActivation3D::is_sleeping(Self) -> Bool
pub fn RigidBodyActivation3D::update(Self, Float, Float, RigidBodyType, RigidBodyVelocity3D) -> Self
pub fn RigidBodyActivation3D::wake_up(Self) -> Self

pub enum RigidBodyAdditionalMassProps {
  Mass(Float)
  MassProps(@core.MassProperties)
  MassProperties(@core.MassProperties)
}
pub fn RigidBodyAdditionalMassProps::mass(Float) -> Self
pub fn RigidBodyAdditionalMassProps::mass_properties(@core.MassProperties) -> Self
pub fn RigidBodyAdditionalMassProps::mass_props(@core.MassProperties) -> Self

pub struct RigidBodyBuilder {
  mut position : @core.Isometry2
  mut linvel : @core.Vec2
  mut angvel : Float
  mut gravity_scale : Float
  mut linear_damping : Float
  mut angular_damping : Float
  body_type : RigidBodyType
  mut lock_translations : Bool
  mut lock_rotations : Bool
  mut additional_mass : Float
  mut additional_solver_iterations : Int
  mut can_sleep : Bool
  mut sleeping : Bool
  mut enabled : Bool
  mut ccd_enabled : Bool
  mut soft_ccd_prediction : Float
  mut dominance_group : Int
}
pub fn RigidBodyBuilder::additional_mass(Self, Float) -> Self
pub fn RigidBodyBuilder::additional_mass_properties(Self, RigidBodyAdditionalMassProps) -> Self
pub fn RigidBodyBuilder::additional_solver_iterations(Self, Int) -> Self
pub fn RigidBodyBuilder::angular_damping(Self, Float) -> Self
pub fn RigidBodyBuilder::angvel(Self, Float) -> Self
pub fn RigidBodyBuilder::build(Self) -> RigidBody
pub fn RigidBodyBuilder::can_sleep(Self, Bool) -> Self
pub fn RigidBodyBuilder::ccd_enabled(Self, Bool) -> Self
pub fn RigidBodyBuilder::dominance_group(Self, Int) -> Self
pub fn RigidBodyBuilder::dynamic() -> Self
pub fn RigidBodyBuilder::enabled(Self, Bool) -> Self
pub fn RigidBodyBuilder::enabled_translations(Self, Bool, Bool, Bool) -> Self
pub fn RigidBodyBuilder::fixed() -> Self
pub fn RigidBodyBuilder::gravity_scale(Self, Float) -> Self
pub fn RigidBodyBuilder::kinematic_position_based() -> Self
pub fn RigidBodyBuilder::kinematic_velocity_based() -> Self
pub fn RigidBodyBuilder::linear_damping(Self, Float) -> Self
pub fn RigidBodyBuilder::linvel(Self, @core.Vec2) -> Self
pub fn RigidBodyBuilder::lock_rotations(Self) -> Self
pub fn RigidBodyBuilder::lock_translations(Self) -> Self
pub fn RigidBodyBuilder::new(RigidBodyType) -> Self
pub fn RigidBodyBuilder::new_kinematic_position_based() -> Self
pub fn RigidBodyBuilder::new_kinematic_velocity_based() -> Self
pub fn RigidBodyBuilder::new_static() -> Self
pub fn RigidBodyBuilder::pose(Self, @core.Isometry2) -> Self
pub fn RigidBodyBuilder::position(Self, @core.Isometry2) -> Self
pub fn RigidBodyBuilder::restrict_rotations(Self, Bool, Bool, Bool) -> Self
pub fn RigidBodyBuilder::restrict_translations(Self, Bool, Bool, Bool) -> Self
pub fn RigidBodyBuilder::rotation(Self, @core.Rot2) -> Self
pub fn RigidBodyBuilder::sleeping(Self, Bool) -> Self
pub fn RigidBodyBuilder::soft_ccd_prediction(Self, Float) -> Self
pub fn RigidBodyBuilder::translation(Self, @core.Vec2) -> Self

pub struct RigidBodyBuilder3 {
  inner : RigidBodyBuilder
}
pub fn RigidBodyBuilder3::additional_mass(Self, Float) -> Self
pub fn RigidBodyBuilder3::angular_damping(Self, Float) -> Self
pub fn RigidBodyBuilder3::angvel(Self, @core.Vec3) -> Self
pub fn RigidBodyBuilder3::build(Self) -> RigidBody
pub fn RigidBodyBuilder3::can_sleep(Self, Bool) -> Self
pub fn RigidBodyBuilder3::ccd_enabled(Self, Bool) -> Self
pub fn RigidBodyBuilder3::dynamic() -> Self
pub fn RigidBodyBuilder3::enabled_rotations(Self, Bool, Bool, Bool) -> Self
pub fn RigidBodyBuilder3::fixed() -> Self
pub fn RigidBodyBuilder3::gravity_scale(Self, Float) -> Self
pub fn RigidBodyBuilder3::gyroscopic_forces_enabled(Self, Bool) -> Self
pub fn RigidBodyBuilder3::kinematic_position_based() -> Self
pub fn RigidBodyBuilder3::kinematic_velocity_based() -> Self
pub fn RigidBodyBuilder3::linear_damping(Self, Float) -> Self
pub fn RigidBodyBuilder3::linvel(Self, @core.Vec3) -> Self
pub fn RigidBodyBuilder3::lock_rotations(Self) -> Self
pub fn RigidBodyBuilder3::lock_translations(Self) -> Self
pub fn RigidBodyBuilder3::rotation(Self, @core.Quat) -> Self
pub fn RigidBodyBuilder3::rotation_scaled_axis(Self, @core.Vec3) -> Self
pub fn RigidBodyBuilder3::soft_ccd_prediction(Self, Float) -> Self
pub fn RigidBodyBuilder3::translation(Self, @core.Vec3) -> Self

pub struct RigidBodyBuilder3D {
  mut body_type : RigidBodyType
  mut translation : @core.Vec3
  mut rotation : @core.Quat
  mut linvel : @core.Vec3
  mut angvel : @core.Vec3
  mut locked_translations : Bool
  mut locked_rotations : Bool
  mut rot_x_enabled : Bool
  mut rot_y_enabled : Bool
  mut rot_z_enabled : Bool
  mut ccd_enabled : Bool
  mut soft_ccd_prediction : Float
  mut gyroscopic_forces_enabled : Bool
  mut linear_damping : Float
  mut angular_damping : Float
  mut gravity_scale : Float
  mut mass_properties : @core.MassProperties3
  mut can_sleep : Bool
}
pub fn RigidBodyBuilder3D::angular_damping(Self, Float) -> Self
pub fn RigidBodyBuilder3D::angvel(Self, @core.Vec3) -> Self
pub fn RigidBodyBuilder3D::build(Self) -> RigidBody3D
pub fn RigidBodyBuilder3D::can_sleep(Self, Bool) -> Self
pub fn RigidBodyBuilder3D::ccd_enabled(Self, Bool) -> Self
pub fn RigidBodyBuilder3D::dynamic() -> Self
pub fn RigidBodyBuilder3D::enabled_rotations(Self, Bool, Bool, Bool) -> Self
pub fn RigidBodyBuilder3D::fixed() -> Self
pub fn RigidBodyBuilder3D::gravity_scale(Self, Float) -> Self
pub fn RigidBodyBuilder3D::gyroscopic_forces_enabled(Self, Bool) -> Self
pub fn RigidBodyBuilder3D::kinematic_position_based() -> Self
pub fn RigidBodyBuilder3D::kinematic_velocity_based() -> Self
pub fn RigidBodyBuilder3D::linear_damping(Self, Float) -> Self
pub fn RigidBodyBuilder3D::linvel(Self, @core.Vec3) -> Self
pub fn RigidBodyBuilder3D::lock_rotations(Self) -> Self
pub fn RigidBodyBuilder3D::lock_translations(Self) -> Self
pub fn RigidBodyBuilder3D::mass_properties(Self, @core.MassProperties3) -> Self
pub fn RigidBodyBuilder3D::rotation(Self, @core.Quat) -> Self
pub fn RigidBodyBuilder3D::rotation_scaled_axis(Self, @core.Vec3) -> Self
pub fn RigidBodyBuilder3D::soft_ccd_prediction(Self, Float) -> Self
pub fn RigidBodyBuilder3D::translation(Self, @core.Vec3) -> Self

pub struct RigidBodyCcd {
  ccd_thickness : Float
  ccd_max_dist : Float
  ccd_active : Bool
  mut ccd_enabled : Bool
  mut soft_ccd_prediction : Float
}
pub fn RigidBodyCcd::default() -> Self
pub fn RigidBodyCcd::is_moving_fast(Self, Float, RigidBodyVelocity, RigidBodyForces?) -> Bool
pub fn RigidBodyCcd::max_point_velocity(Self, RigidBodyVelocity) -> Float

pub struct RigidBodyChanges {
  bits : Int
}
pub fn RigidBodyChanges::all() -> Self
pub fn RigidBodyChanges::colliders_flag() -> Int
pub fn RigidBodyChanges::contains(Self, Int) -> Bool
pub fn RigidBodyChanges::dominance_flag() -> Int
pub fn RigidBodyChanges::empty() -> Self
pub fn RigidBodyChanges::insert(Self, Int) -> Self
pub fn RigidBodyChanges::remove(Self, Int) -> Self
pub fn RigidBodyChanges::sleep_flag() -> Int

pub struct RigidBodyColliders {
  colliders : Array[Int]
}
pub fn RigidBodyColliders::attach_collider(Self, Int) -> Self
pub fn RigidBodyColliders::detach_collider(Self, Int) -> Self
pub fn RigidBodyColliders::new() -> Self

pub struct RigidBodyDamping {
  mut linear_damping : Float
  mut angular_damping : Float
}
pub fn RigidBodyDamping::default() -> Self

pub struct RigidBodyDominance {
  mut group : Int
}
pub fn RigidBodyDominance::default() -> Self
pub fn RigidBodyDominance::effective_group(Self, RigidBodyType) -> Int
pub fn RigidBodyDominance::new(Int) -> Self

pub struct RigidBodyForces {
  mut force : @core.Vec2
  mut torque : Float
  mut gravity_scale : Float
  mut user_force : @core.Vec2
  mut user_torque : Float
}
pub fn RigidBodyForces::apply_force_at_point(Self, RigidBodyMassProps, @core.Vec2, @core.Vec2) -> Self
pub fn RigidBodyForces::compute_effective_force_and_torque(Self, @core.Vec2, @core.Vec2) -> Self
pub fn RigidBodyForces::default() -> Self
pub fn RigidBodyForces::integrate(Self, Float, RigidBodyVelocity, RigidBodyMassProps) -> RigidBodyVelocity

pub struct RigidBodyHandle {
  id : Int
  generation : Int
}
pub fn RigidBodyHandle::equals(Self, Self) -> Bool
pub fn RigidBodyHandle::from_raw_parts(Int, Int) -> Self
pub fn RigidBodyHandle::into_raw_parts(Self) -> (Int, Int)
pub fn RigidBodyHandle::invalid() -> Self

pub struct RigidBodyIds {
  mut active_island_id : Int
  mut active_set_id : Int
  mut active_set_timestamp : Int
}
pub fn RigidBodyIds::default() -> Self

pub struct RigidBodyMassProps {
  mut world_com : @core.Vec2
  mut effective_inv_mass : @core.Vec2
  mut effective_world_inv_inertia : Float
  mut local_mprops : @core.MassProperties
  additional_local_mprops : @core.MassProperties
}
pub fn RigidBodyMassProps::default() -> Self
pub fn RigidBodyMassProps::effective_angular_inertia(Self) -> Float
pub fn RigidBodyMassProps::effective_mass(Self) -> @core.Vec2
pub fn RigidBodyMassProps::recompute_mass_properties_from_colliders(Self) -> Self
pub fn RigidBodyMassProps::set_effective_inv_mass(Self, @core.Vec2) -> Self
pub fn RigidBodyMassProps::set_effective_world_inv_inertia(Self, Float) -> Self
pub fn RigidBodyMassProps::update_world_mass_properties(Self, RigidBodyType, @core.Isometry2) -> Self

pub struct RigidBodyPosition {
  mut position : @core.Isometry2
  mut next_position : @core.Isometry2
}
pub fn RigidBodyPosition::integrate_forces_and_velocities(Self, Float, RigidBodyForces, RigidBodyVelocity, RigidBodyMassProps) -> @core.Isometry2
pub fn RigidBodyPosition::interpolate_velocity(Self, Float, @core.Vec2) -> RigidBodyVelocity
pub fn RigidBodyPosition::new(@core.Isometry2, @core.Isometry2) -> Self

pub struct RigidBodyPosition3 {
  position : @core.Isometry3
  next_position : @core.Isometry3
}
pub fn RigidBodyPosition3::interpolate_velocity(Self, Float, @core.Vec3) -> RigidBodyVelocity3
pub fn RigidBodyPosition3::new(@core.Isometry3, @core.Isometry3) -> Self
pub fn RigidBodyPosition3::pose_errors(Self, @core.Vec3) -> PdErrors3

pub struct RigidBodyPosition3D {
  position : @core.Isometry3
  next_position : @core.Isometry3
}
pub fn RigidBodyPosition3D::interpolate_velocity(Self, Float, @core.Vec3) -> RigidBodyVelocity3D
pub fn RigidBodyPosition3D::new(@core.Isometry3, @core.Isometry3) -> Self

pub struct RigidBodySet {
  bodies : Array[RigidBody?]
  generations : Array[Int]
  free_list : Array[Int]
  modified_bodies : Array[RigidBodyHandle]
}
pub fn RigidBodySet::contains(Self, RigidBodyHandle) -> Bool
pub fn RigidBodySet::deserialize(String) -> Self
pub fn RigidBodySet::get(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet::get_mut(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet::get_mut_internal(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet::get_mut_internal_with_modification_tracking(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet::get_pair_mut(Self, RigidBodyHandle, RigidBodyHandle) -> (RigidBody?, RigidBody?)
pub fn RigidBodySet::get_unknown_gen(Self, Int) -> (RigidBody, RigidBodyHandle)?
pub fn RigidBodySet::get_unknown_gen_mut(Self, Int) -> (RigidBody, RigidBodyHandle)?
pub fn RigidBodySet::insert(Self, RigidBody) -> RigidBodyHandle
pub fn RigidBodySet::is_empty(Self) -> Bool
pub fn RigidBodySet::iter(Self) -> Array[(RigidBodyHandle, RigidBody)]
pub fn RigidBodySet::iter_mut(Self) -> Array[(RigidBodyHandle, RigidBody)]
pub fn RigidBodySet::len(Self) -> Int
pub fn RigidBodySet::new() -> Self
pub fn RigidBodySet::propagate_modified_body_positions_to_colliders(Self) -> Unit
pub fn RigidBodySet::remove(Self, RigidBodyHandle, IslandManager, Unit, ImpulseJointSet, MultibodyJointSet, Bool) -> RigidBody?
pub fn RigidBodySet::serialize(Self) -> String
pub fn RigidBodySet::take_modified(Self) -> Array[RigidBodyHandle]
pub fn RigidBodySet::with_capacity(Int) -> Self

pub struct RigidBodySet3 {
  inner : RigidBodySet
}
pub fn RigidBodySet3::as_2d(Self) -> RigidBodySet
pub fn RigidBodySet3::get(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet3::get_mut(Self, RigidBodyHandle) -> RigidBody?
pub fn RigidBodySet3::insert(Self, RigidBody) -> RigidBodyHandle
pub fn RigidBodySet3::len(Self) -> Int
pub fn RigidBodySet3::new() -> Self
pub fn RigidBodySet3::remove(Self, RigidBodyHandle, IslandManager3, Unit, ImpulseJointSet3, MultibodyJointSet3, Bool) -> RigidBody?
pub fn RigidBodySet3::rotation(Self, RigidBodyHandle) -> @core.Quat
pub fn RigidBodySet3::translation(Self, RigidBodyHandle) -> @core.Vec3

pub struct RigidBodySet3D {
  bodies : Array[RigidBody3D?]
  generations : Array[Int]
  free_list : Array[Int]
}
pub fn RigidBodySet3D::advance_positions_all(Self, Float) -> Unit
pub fn RigidBodySet3D::all_handles(Self) -> Array[RigidBodyHandle]
pub fn RigidBodySet3D::apply_damping_all(Self, Float) -> Unit
pub fn RigidBodySet3D::apply_gravity_all(Self, @core.Vec3, Float) -> Unit
pub fn RigidBodySet3D::apply_gyroscopic_forces_all(Self, Float) -> Unit
pub fn RigidBodySet3D::get(Self, RigidBodyHandle) -> RigidBody3D?
pub fn RigidBodySet3D::get_mut(Self, RigidBodyHandle) -> RigidBody3D?
pub fn RigidBodySet3D::has_ccd_enabled(Self) -> Bool
pub fn RigidBodySet3D::insert(Self, RigidBody3D) -> RigidBodyHandle
pub fn RigidBodySet3D::integrate_all(Self, @core.Vec3, Float) -> Unit
pub fn RigidBodySet3D::len(Self) -> Int
pub fn RigidBodySet3D::max_linvel_len(Self) -> Float
pub fn RigidBodySet3D::new() -> Self
pub fn RigidBodySet3D::remove(Self, RigidBodyHandle) -> RigidBody3D?
pub fn RigidBodySet3D::update_kinematic_velocities_all(Self, Float) -> Unit
pub fn RigidBodySet3D::update_sleep_all(Self, Float, Float) -> Unit

#alias(BodyStatus)
pub(all) enum RigidBodyType {
  Dynamic
  Fixed
  KinematicPositionBased
  KinematicVelocityBased
}
pub fn RigidBodyType::is_dynamic(Self) -> Bool
pub fn RigidBodyType::is_dynamic_or_kinematic(Self) -> Bool
pub fn RigidBodyType::is_fixed(Self) -> Bool
pub fn RigidBodyType::is_kinematic(Self) -> Bool

pub struct RigidBodyVelocity {
  mut linvel : @core.Vec2
  mut angvel : Float
}
pub fn RigidBodyVelocity::angvel(Self) -> Float
pub fn RigidBodyVelocity::apply_damping(Self, Float, RigidBodyDamping) -> Self
pub fn RigidBodyVelocity::as_mut_slice(Self) -> Array[Float]
pub fn RigidBodyVelocity::as_slice(Self) -> Array[Float]
pub fn RigidBodyVelocity::as_vector(Self) -> @core.Vec3
pub fn RigidBodyVelocity::as_vector_mut(Self) -> @core.Vec3
pub fn RigidBodyVelocity::from_slice(Array[Float]) -> Self
pub fn RigidBodyVelocity::integrate(Self, Float, @core.Isometry2, @core.Vec2) -> @core.Isometry2
pub fn RigidBodyVelocity::is_zero(Self) -> Bool
pub fn RigidBodyVelocity::kinetic_energy(Self, RigidBodyMassProps) -> Float
pub fn RigidBodyVelocity::linvel(Self) -> @core.Vec2
pub fn RigidBodyVelocity::new(@core.Vec2, Float) -> Self
pub fn RigidBodyVelocity::pseudo_kinetic_energy(Self) -> Float
pub fn RigidBodyVelocity::transformed(Self, @core.Rot2) -> Self
pub fn RigidBodyVelocity::velocity_at_point(Self, @core.Vec2, @core.Vec2) -> @core.Vec2
pub fn RigidBodyVelocity::zero() -> Self

pub struct RigidBodyVelocity3 {
  linvel : @core.Vec3
  angvel : @core.Vec3
}
pub fn RigidBodyVelocity3::integrate(Self, Float, @core.Isometry3, @core.Vec3) -> @core.Isometry3

pub struct RigidBodyVelocity3D {
  linvel : @core.Vec3
  angvel : @core.Vec3
}
pub fn RigidBodyVelocity3D::angvel(Self) -> @core.Vec3
pub fn RigidBodyVelocity3D::apply_damping(Self, Float, Float, Float) -> Self
pub fn RigidBodyVelocity3D::integrate(Self, Float, @core.Isometry3, @core.Vec3) -> @core.Isometry3
pub fn RigidBodyVelocity3D::linvel(Self) -> @core.Vec3
pub fn RigidBodyVelocity3D::zero() -> Self

pub struct RopeJoint {
  max_length : Float
  local_anchor1 : @core.Vec2
  local_anchor2 : @core.Vec2
}
pub fn RopeJoint::max_distance(Self) -> Float
pub fn RopeJoint::max_length(Self) -> Float
pub fn RopeJoint::set_max_distance(Self, Float) -> Self

pub struct RopeJoint3DReal {
  body1 : RigidBodyHandle
  body2 : RigidBodyHandle
  max_length : Float
}

pub struct RopeJointBuilder {
  max_length : Float
  mut local_anchor1 : @core.Vec2
  mut local_anchor2 : @core.Vec2
}
pub fn RopeJointBuilder::build(Self) -> RopeJoint
pub fn RopeJointBuilder::local_anchor1(Self, @core.Vec2) -> Self
pub fn RopeJointBuilder::local_anchor2(Self, @core.Vec2) -> Self
pub fn RopeJointBuilder::max_distance(Self) -> Float
pub fn RopeJointBuilder::new(Float) -> Self

pub struct RopeJointBuilder3 {
  inner : RopeJointBuilder
}
pub fn RopeJointBuilder3::build(Self) -> RopeJoint
pub fn RopeJointBuilder3::local_anchor1(Self, @core.Vec3) -> Self
pub fn RopeJointBuilder3::local_anchor2(Self, @core.Vec3) -> Self
pub fn RopeJointBuilder3::new(Float) -> Self

pub struct RopeJointSet3DReal {
  joints : Array[RopeJoint3DReal]
}
pub fn RopeJointSet3DReal::insert(Self, RigidBodyHandle, RigidBodyHandle, Float) -> Unit
pub fn RopeJointSet3DReal::new() -> Self
pub fn RopeJointSet3DReal::solve(Self, RigidBodySet3D, Float) -> Unit

type RowDVector
pub fn RowDVector::equals(Self, Self) -> Bool
pub fn RowDVector::from_array(Array[Float]) -> Self
pub fn RowDVector::from_fn(Int, (Int) -> Float) -> Self
pub fn RowDVector::len(Self) -> Int
pub fn RowDVector::scale(Self, Float) -> Self

type SleepCandidate

type SleepRootState

pub struct SphericalJoint3DReal {
  body1 : RigidBodyHandle
  body2 : RigidBodyHandle
  local_anchor1 : @core.Vec3
  local_anchor2 : @core.Vec3
}

pub struct SphericalJoint3DRealBuilder {
  inner : GenericJoint3DRealBuilder
}
pub fn SphericalJoint3DRealBuilder::build(Self) -> GenericJoint3DReal
pub fn SphericalJoint3DRealBuilder::limits(Self, JointAxis3DReal, Float, Float) -> Self
pub fn SphericalJoint3DRealBuilder::local_anchor1(Self, @core.Vec3) -> Self
pub fn SphericalJoint3DRealBuilder::local_anchor2(Self, @core.Vec3) -> Self
pub fn SphericalJoint3DRealBuilder::motor_max_force(Self, JointAxis3DReal, Float) -> Self
pub fn SphericalJoint3DRealBuilder::motor_position(Self, JointAxis3DReal, Float, Float, Float) -> Self
pub fn SphericalJoint3DRealBuilder::motor_velocity(Self, JointAxis3DReal, Float, Float) -> Self
pub fn SphericalJoint3DRealBuilder::new() -> Self

pub struct SphericalMotor3DReal {
  body1 : RigidBodyHandle
  body2 : RigidBodyHandle
  target_rel_rotation : @core.Quat
  stiffness : Float
  damping : Float
}

pub struct SpringCoefficients {
  natural_frequency : Float
  damping_ratio : Float
}
pub fn SpringCoefficients::angular_frequency(Self) -> Float
pub fn SpringCoefficients::cfm_coeff(Self, Float) -> Float
pub fn SpringCoefficients::cfm_factor(Self, Float) -> Float
pub fn SpringCoefficients::contact_defaults() -> Self
pub fn SpringCoefficients::erp(Self, Float) -> Float
pub fn SpringCoefficients::erp_inv_dt(Self, Float) -> Float
pub fn SpringCoefficients::joint_defaults() -> Self
pub fn SpringCoefficients::new(Float, Float) -> Self

pub struct SpringJoint {
  mut data : GenericJoint
}
pub fn SpringJoint::contacts_enabled(Self) -> Bool
pub fn SpringJoint::data(Self) -> GenericJoint
pub fn SpringJoint::local_anchor1(Self) -> @core.Vec2
pub fn SpringJoint::local_anchor2(Self) -> @core.Vec2
pub fn SpringJoint::new(Float, Float, Float) -> Self
pub fn SpringJoint::set_contacts_enabled(Self, Bool) -> Self
pub fn SpringJoint::set_local_anchor1(Self, @core.Vec2) -> Self
pub fn SpringJoint::set_local_anchor2(Self, @core.Vec2) -> Self
pub fn SpringJoint::set_spring_model(Self, MotorModel) -> Self

pub struct SpringJoint3DReal {
  body1 : RigidBodyHandle
  body2 : RigidBodyHandle
  local_anchor1 : @core.Vec3
  local_anchor2 : @core.Vec3
  rest_length : Float
  stiffness : Float
  damping : Float
}

pub struct SpringJointBuilder {
  mut inner : SpringJoint
}
pub fn SpringJointBuilder::build(Self) -> SpringJoint
pub fn SpringJointBuilder::contacts_enabled(Self, Bool) -> Self
pub fn SpringJointBuilder::local_anchor1(Self, @core.Vec2) -> Self
pub fn SpringJointBuilder::local_anchor2(Self, @core.Vec2) -> Self
pub fn SpringJointBuilder::new(Float, Float, Float) -> Self
pub fn SpringJointBuilder::spring_model(Self, MotorModel) -> Self

pub(all) enum WritebackId {
  Dof(Int)
  Limit(Int)
  Motor(Int)
}

// Type aliases

// Traits

