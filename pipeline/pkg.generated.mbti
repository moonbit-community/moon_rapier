// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_rapier/pipeline"

import {
  "Milky2018/moon_rapier/collision",
  "Milky2018/moon_rapier/core",
  "Milky2018/moon_rapier/counters",
  "Milky2018/moon_rapier/dynamics",
  "moonbitlang/core/hashmap",
}

// Values
pub fn parallel_enabled() -> Bool

pub fn parallel_strategy() -> String

pub fn remove_rigid_body(@dynamics.RigidBodySet, @dynamics.RigidBodyHandle, @dynamics.IslandManager, @collision.ColliderSet, @dynamics.ImpulseJointSet, @dynamics.MultibodyJointSet, Bool, Bool) -> @dynamics.RigidBody?

pub fn remove_rigid_body3(@dynamics.RigidBodySet3, @dynamics.RigidBodyHandle, @dynamics.IslandManager3, @collision.ColliderSet3, @dynamics.ImpulseJointSet3, @dynamics.MultibodyJointSet3, Bool, Bool) -> @dynamics.RigidBody?

pub fn simd_enabled() -> Bool

pub fn simd_strategy() -> String

pub fn solve_contacts(@dynamics.IntegrationParameters, @dynamics.RigidBodySet, @collision.ColliderSet, PhysicsHooks, @collision.NarrowPhase, Float, EventHandler, Array[ContactImpulseCacheEntry]) -> Unit

pub fn solve_contacts_3d(@dynamics.IntegrationParameters, @dynamics.RigidBodySet3D, @collision.ColliderSet3D, @collision.NarrowPhase3D, ContactSolverCache3D, ContactSolverCache3D, EventHandler3D?) -> Unit

// Errors

// Types and methods
pub struct ChannelEventCollector {
  handler : EventHandler
}
pub fn ChannelEventCollector::handle_collision_event(Self, @dynamics.RigidBodySet, @collision.ColliderSet, @collision.CollisionEvent) -> Unit
pub fn ChannelEventCollector::handle_contact_force_event(Self, Float, @dynamics.RigidBodySet, @collision.ColliderSet, @collision.ContactForceEvent) -> Unit
pub fn ChannelEventCollector::handle_intersection_event(Self, @dynamics.RigidBodySet, @collision.ColliderSet, @collision.IntersectionEvent) -> Unit
pub fn ChannelEventCollector::new() -> Self
pub fn ChannelEventCollector::take_collision_events(Self) -> Array[@collision.CollisionEvent]
pub fn ChannelEventCollector::take_contact_force_events(Self) -> Array[@collision.ContactForceEvent]
pub fn ChannelEventCollector::take_intersection_events(Self) -> Array[@collision.IntersectionEvent]

pub struct CollisionPipeline {
}
pub fn CollisionPipeline::new() -> Self
pub fn CollisionPipeline::step(Self, Float, @dynamics.IslandManager, @collision.BroadPhaseBvh, @collision.NarrowPhase, @dynamics.RigidBodySet, @collision.ColliderSet, @dynamics.ImpulseJointSet, @dynamics.MultibodyJointSet, PhysicsHooks, EventHandler) -> Unit

pub struct CollisionPipeline3 {
  inner : CollisionPipeline
}
pub fn CollisionPipeline3::new() -> Self
pub fn CollisionPipeline3::step(Self, Float, @dynamics.IslandManager3, @collision.BroadPhaseBvh, @collision.NarrowPhase, @dynamics.RigidBodySet3, @collision.ColliderSet3, PhysicsHooks, EventHandler) -> Unit

pub struct ContactImpulse3D {
  normal : Float
  tangent1 : Float
  tangent2 : Float
}
pub fn ContactImpulse3D::scaled(Self, Float) -> Self
pub fn ContactImpulse3D::zero() -> Self

pub struct ContactImpulseCacheEntry {
  collider1 : @collision.ColliderHandle
  collider2 : @collision.ColliderHandle
  fid1 : @collision.FeatureId
  fid2 : @collision.FeatureId
  impulse_n : Float
  impulse_t : Float
}

pub struct ContactModificationContext {
  bodies : @dynamics.RigidBodySet
  colliders : @collision.ColliderSet
  collider1 : @collision.ColliderHandle
  collider2 : @collision.ColliderHandle
  rigid_body1 : @dynamics.RigidBodyHandle?
  rigid_body2 : @dynamics.RigidBodyHandle?
  manifold : @collision.ContactManifold
  solver_contacts : Array[@collision.SolverContact]
  mut normal : @core.Vec2
  mut user_data : Int
}
pub fn ContactModificationContext::new(@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @dynamics.RigidBodyHandle?, @dynamics.RigidBodyHandle?, @collision.ContactManifold, Array[@collision.SolverContact], @core.Vec2, Int) -> Self
pub fn ContactModificationContext::normal(Self) -> @core.Vec2
pub fn ContactModificationContext::set_normal(Self, @core.Vec2) -> Unit
pub fn ContactModificationContext::set_user_data(Self, Int) -> Unit
pub fn ContactModificationContext::update_as_oneway_platform(Self, @core.Vec2, Float) -> Unit

pub struct ContactSolverCache3D {
  entries : @hashmap.HashMap[(Int, Int, Int, Int), Array[(@core.Vec3, @core.Vec3, ContactImpulse3D)]]
}
pub fn ContactSolverCache3D::clear(Self) -> Unit
pub fn ContactSolverCache3D::new() -> Self

pub struct DebugColor {
  h : Float
  s : Float
  l : Float
  a : Float
}
pub fn DebugColor::new(Float, Float, Float, Float) -> Self

pub struct DebugRenderBackend {
  lines : Array[DebugRenderLine]
}
pub fn DebugRenderBackend::draw_line(Self, DebugRenderObject, @core.Vec2, @core.Vec2, DebugColor) -> Unit
pub fn DebugRenderBackend::lines(Self) -> Array[DebugRenderLine]
pub fn DebugRenderBackend::new() -> Self
pub fn DebugRenderBackend::serialize_lines(Self) -> String

pub struct DebugRenderLine {
  object : DebugRenderObject
  a : @core.Vec2
  b : @core.Vec2
  color : DebugColor
}

pub struct DebugRenderMode {
  mut bits : Int
}
pub fn DebugRenderMode::all() -> Self
pub fn DebugRenderMode::collider_aabbs() -> Self
pub fn DebugRenderMode::collider_shapes() -> Self
pub fn DebugRenderMode::contacts() -> Self
pub fn DebugRenderMode::contains(Self, Self) -> Bool
pub fn DebugRenderMode::default() -> Self
pub fn DebugRenderMode::empty() -> Self
pub fn DebugRenderMode::impulse_joints() -> Self
pub fn DebugRenderMode::insert(Self, Self) -> Self
pub fn DebugRenderMode::joints() -> Self
pub fn DebugRenderMode::multibody_joints() -> Self
pub fn DebugRenderMode::remove(Self, Self) -> Self
pub fn DebugRenderMode::rigid_body_axes() -> Self
pub fn DebugRenderMode::solver_contacts() -> Self

pub(all) enum DebugRenderObject {
  RigidBody(@dynamics.RigidBodyHandle)
  Collider(@collision.ColliderHandle)
  ImpulseJoint(@dynamics.ImpulseJointHandle)
  MultibodyJoint(@dynamics.MultibodyJointHandle)
  ContactPair(@collision.ColliderHandle, @collision.ColliderHandle)
}

pub struct DebugRenderPipeline {
  style : DebugRenderStyle
  mode : DebugRenderMode
}
pub fn DebugRenderPipeline::default() -> Self
pub fn DebugRenderPipeline::new(DebugRenderStyle, DebugRenderMode) -> Self
pub fn DebugRenderPipeline::render(Self, DebugRenderBackend, @dynamics.RigidBodySet, @collision.ColliderSet, @dynamics.ImpulseJointSet, @dynamics.MultibodyJointSet, @collision.NarrowPhase) -> Unit
pub fn DebugRenderPipeline::render_all(DebugRenderStyle) -> Self

pub struct DebugRenderStyle {
  subdivisions : Int
  border_subdivisions : Int
  collider_dynamic_color : DebugColor
  collider_fixed_color : DebugColor
  collider_kinematic_color : DebugColor
  collider_parentless_color : DebugColor
  impulse_joint_anchor_color : DebugColor
  impulse_joint_separation_color : DebugColor
  multibody_joint_anchor_color : DebugColor
  multibody_joint_separation_color : DebugColor
  sleep_color_multiplier : DebugColor
  disabled_color_multiplier : DebugColor
  rigid_body_axes_length : Float
  contact_depth_color : DebugColor
  contact_normal_color : DebugColor
  contact_normal_length : Float
  collider_aabb_color : DebugColor
}
pub fn DebugRenderStyle::default() -> Self

pub struct EventHandler {
  collision_events : Array[@collision.CollisionEvent]
  mut collision_callback : ((@dynamics.RigidBodySet, @collision.ColliderSet, @collision.CollisionEvent) -> Unit)?
  intersection_events : Array[@collision.IntersectionEvent]
  mut intersection_callback : ((@dynamics.RigidBodySet, @collision.ColliderSet, @collision.IntersectionEvent) -> Unit)?
  contact_force_events : Array[@collision.ContactForceEvent]
  mut contact_force_callback : ((Float, @dynamics.RigidBodySet, @collision.ColliderSet, @collision.ContactForceEvent) -> Unit)?
}
pub fn EventHandler::handle_collision_event(Self, @dynamics.RigidBodySet, @collision.ColliderSet, @collision.CollisionEvent) -> Unit
pub fn EventHandler::handle_contact_force_event(Self, Float, @dynamics.RigidBodySet, @collision.ColliderSet, @collision.ContactForceEvent) -> Unit
pub fn EventHandler::handle_intersection_event(Self, @dynamics.RigidBodySet, @collision.ColliderSet, @collision.IntersectionEvent) -> Unit
pub fn EventHandler::new() -> Self
pub fn EventHandler::on_collision_event(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.CollisionEvent) -> Unit) -> Self
pub fn EventHandler::on_contact_force_event(Self, (Float, @dynamics.RigidBodySet, @collision.ColliderSet, @collision.ContactForceEvent) -> Unit) -> Self
pub fn EventHandler::on_intersection_event(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.IntersectionEvent) -> Unit) -> Self
pub fn EventHandler::push_collision_event(Self, @collision.CollisionEvent) -> Unit
pub fn EventHandler::push_contact_force_event(Self, @collision.ContactForceEvent) -> Unit
pub fn EventHandler::push_intersection_event(Self, @collision.IntersectionEvent) -> Unit
pub fn EventHandler::take_collision_events(Self) -> Array[@collision.CollisionEvent]
pub fn EventHandler::take_contact_force_events(Self) -> Array[@collision.ContactForceEvent]
pub fn EventHandler::take_intersection_events(Self) -> Array[@collision.IntersectionEvent]

pub struct EventHandler3D {
  collision_events : Array[@collision.CollisionEvent3D]
  intersection_events : Array[@collision.IntersectionEvent3D]
  contact_force_events : Array[@collision.ContactForceEvent3D]
}
pub fn EventHandler3D::new() -> Self
pub fn EventHandler3D::push_collision_event(Self, @collision.CollisionEvent3D) -> Unit
pub fn EventHandler3D::push_contact_force_event(Self, @collision.ContactForceEvent3D) -> Unit
pub fn EventHandler3D::push_intersection_event(Self, @collision.IntersectionEvent3D) -> Unit
pub fn EventHandler3D::take_collision_events(Self) -> Array[@collision.CollisionEvent3D]
pub fn EventHandler3D::take_contact_force_events(Self) -> Array[@collision.ContactForceEvent3D]
pub fn EventHandler3D::take_intersection_events(Self) -> Array[@collision.IntersectionEvent3D]

pub struct PairFilterContext {
  bodies : @dynamics.RigidBodySet
  colliders : @collision.ColliderSet
  collider1 : @collision.ColliderHandle
  collider2 : @collision.ColliderHandle
  rigid_body1 : @dynamics.RigidBodyHandle?
  rigid_body2 : @dynamics.RigidBodyHandle?
}
pub fn PairFilterContext::new(@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @dynamics.RigidBodyHandle?, @dynamics.RigidBodyHandle?) -> Self

pub struct PhysicsHooks {
  mut filter_contact_pair : ((@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle) -> Bool)?
  mut filter_intersection_pair : ((@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle) -> Bool)?
  mut modify_solver_contacts : ((@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @collision.ContactManifold) -> (Bool, @core.Vec2))?
  mut modify_solver_contacts_with_solver_contacts : ((@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @collision.ContactManifold, Array[@collision.SolverContact], @collision.SolverFlags) -> @collision.SolverFlags)?
}
pub fn PhysicsHooks::filter_contact_pair(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle) -> Bool) -> Self
pub fn PhysicsHooks::filter_contact_pair_with_user_data(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @core.UserData128, @core.UserData128, @dynamics.RigidBodyHandle?, @dynamics.RigidBodyHandle?, @core.UserData128?, @core.UserData128?) -> Bool) -> Self
pub fn PhysicsHooks::filter_intersection_pair(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle) -> Bool) -> Self
pub fn PhysicsHooks::filter_intersection_pair_with_user_data(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @core.UserData128, @core.UserData128, @dynamics.RigidBodyHandle?, @dynamics.RigidBodyHandle?, @core.UserData128?, @core.UserData128?) -> Bool) -> Self
pub fn PhysicsHooks::modify_solver_contacts(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @collision.ContactManifold) -> (Bool, @core.Vec2)) -> Self
pub fn PhysicsHooks::modify_solver_contacts_with_solver_contacts(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @collision.ContactManifold, Array[@collision.SolverContact], @collision.SolverFlags) -> @collision.SolverFlags) -> Self
pub fn PhysicsHooks::modify_solver_contacts_with_solver_contacts_with_user_data(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @core.UserData128, @core.UserData128, @dynamics.RigidBodyHandle?, @dynamics.RigidBodyHandle?, @core.UserData128?, @core.UserData128?, @collision.ContactManifold, Array[@collision.SolverContact], @collision.SolverFlags) -> @collision.SolverFlags) -> Self
pub fn PhysicsHooks::modify_solver_contacts_with_user_data(Self, (@dynamics.RigidBodySet, @collision.ColliderSet, @collision.ColliderHandle, @collision.ColliderHandle, @core.UserData128, @core.UserData128, @dynamics.RigidBodyHandle?, @dynamics.RigidBodyHandle?, @core.UserData128?, @core.UserData128?, @collision.ContactManifold) -> (Bool, @core.Vec2)) -> Self
pub fn PhysicsHooks::new() -> Self

pub struct PhysicsPipeline {
  prev_collisions : Array[(@collision.ColliderHandle, @collision.ColliderHandle, @collision.CollisionEventFlags, Bool)]
  prev_intersections : Array[(@collision.ColliderHandle, @collision.ColliderHandle, Bool)]
  contact_solver_cache : Array[ContactImpulseCacheEntry]
  counters : @counters.Counters
}
pub fn PhysicsPipeline::new() -> Self
pub fn PhysicsPipeline::step(Self, @core.Vec2, @dynamics.IntegrationParameters, @dynamics.IslandManager, @collision.BroadPhaseBvh, @collision.NarrowPhase, @dynamics.RigidBodySet, @collision.ColliderSet, @dynamics.ImpulseJointSet, @dynamics.MultibodyJointSet, @dynamics.CCDSolver, PhysicsHooks, EventHandler) -> Unit

pub struct PhysicsPipeline3 {
  inner : PhysicsPipeline
}
pub fn PhysicsPipeline3::new() -> Self
pub fn PhysicsPipeline3::step(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.IslandManager3, @collision.BroadPhaseBvh, @collision.NarrowPhase, @dynamics.RigidBodySet3, @collision.ColliderSet3, @dynamics.ImpulseJointSet3, @dynamics.MultibodyJointSet3, @dynamics.CCDSolver, PhysicsHooks, EventHandler) -> Unit

pub struct PhysicsPipeline3D {
  inner : PhysicsPipeline3DReal
}
pub fn PhysicsPipeline3D::new() -> Self
pub fn PhysicsPipeline3D::step(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.IslandManager3D, @collision.BroadPhase3D, @collision.NarrowPhase3D, @dynamics.RigidBodySet3D, @collision.ColliderSet3D) -> Unit
pub fn PhysicsPipeline3D::step_integration_only(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.RigidBodySet3D) -> Unit
pub fn PhysicsPipeline3D::step_with_events(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.IslandManager3D, @collision.BroadPhase3D, @collision.NarrowPhase3D, @dynamics.RigidBodySet3D, @collision.ColliderSet3D, EventHandler3D) -> Unit
pub fn PhysicsPipeline3D::step_with_joints(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.IslandManager3D, @collision.BroadPhase3D, @collision.NarrowPhase3D, @dynamics.RigidBodySet3D, @collision.ColliderSet3D, @dynamics.JointSet3DReal) -> Unit
pub fn PhysicsPipeline3D::step_with_rope_joints(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.IslandManager3D, @collision.BroadPhase3D, @collision.NarrowPhase3D, @dynamics.RigidBodySet3D, @collision.ColliderSet3D, @dynamics.RopeJointSet3DReal) -> Unit

pub struct PhysicsPipeline3DReal {
  mut contact_cache : ContactSolverCache3D
  sensor_pairs : Array[(@collision.ColliderHandle3D, @collision.ColliderHandle3D)]
  contact_pairs : Array[(@collision.ColliderHandle3D, @collision.ColliderHandle3D)]
  intersection_pairs : Array[(@collision.ColliderHandle3D, @collision.ColliderHandle3D)]
}
pub fn PhysicsPipeline3DReal::new() -> Self
pub fn PhysicsPipeline3DReal::step(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.IslandManager3D, @collision.BroadPhase3D, @collision.NarrowPhase3D, @dynamics.RigidBodySet3D, @collision.ColliderSet3D) -> Unit
pub fn PhysicsPipeline3DReal::step_with_events(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.IslandManager3D, @collision.BroadPhase3D, @collision.NarrowPhase3D, @dynamics.RigidBodySet3D, @collision.ColliderSet3D, EventHandler3D) -> Unit
pub fn PhysicsPipeline3DReal::step_with_joints(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.IslandManager3D, @collision.BroadPhase3D, @collision.NarrowPhase3D, @dynamics.RigidBodySet3D, @collision.ColliderSet3D, @dynamics.JointSet3DReal) -> Unit
pub fn PhysicsPipeline3DReal::step_with_rope_joints(Self, @core.Vec3, @dynamics.IntegrationParameters, @dynamics.IslandManager3D, @collision.BroadPhase3D, @collision.NarrowPhase3D, @dynamics.RigidBodySet3D, @collision.ColliderSet3D, @dynamics.RopeJointSet3DReal) -> Unit

pub struct SolverBodies {
  vels : Array[SolverVel]
  poses : Array[SolverPose]
}
pub fn SolverBodies::clear(Self) -> Unit
pub fn SolverBodies::copy_from(Self, Int, @dynamics.RigidBody) -> Unit
pub fn SolverBodies::default() -> Self
pub fn SolverBodies::len(Self) -> Int
pub fn SolverBodies::resize(Self, Int) -> Unit
pub fn SolverBodies::writeback_vels(Self, @dynamics.RigidBodySet) -> Unit

pub struct SolverPose {
  mut translation : @core.Vec2
  mut rotation : @core.Rot2
  mut im : @core.Vec2
  mut ii : Float
  padding : Float
}
pub fn SolverPose::zero() -> Self

pub struct SolverVel {
  mut linear : @core.Vec2
  mut angular : Float
}
pub fn SolverVel::zero() -> Self

// Type aliases
pub using @dynamics {type IntegrationParameters}

// Traits

