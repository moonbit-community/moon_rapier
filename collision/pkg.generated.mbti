// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_rapier/collision"

import {
  "Milky2018/moon_rapier/core",
  "Milky2018/moon_rapier/dynamics",
}

// Values
pub fn compute_ball_ball_contact(@core.Vec3, Float, @core.Vec3, Float) -> ContactPoint3D?

pub fn compute_ball_capsule_contact(@core.Vec3, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_ball_cone_contact(@core.Vec3, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_ball_cuboid_contact(@core.Vec3, Float, @core.Isometry3, @core.Vec3) -> ContactPoint3D?

pub fn compute_ball_cylinder_contact(@core.Vec3, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_capsule_capsule_contact(@core.Isometry3, Float, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_capsule_cuboid_contact(@core.Isometry3, Float, Float, @core.Isometry3, @core.Vec3) -> ContactPoint3D?

pub fn compute_cuboid_cuboid_contact(@core.Isometry3, @core.Vec3, @core.Isometry3, @core.Vec3) -> ContactPoint3D?

pub fn handle_user_changes_to_colliders(@dynamics.RigidBodySet, ColliderSet, Array[ColliderHandle]) -> Unit

// Errors

// Types and methods
pub struct ActiveCollisionTypes {
  value : Int
}
pub fn ActiveCollisionTypes::all() -> Self
pub fn ActiveCollisionTypes::default() -> Self
pub fn ActiveCollisionTypes::equals(Self, Self) -> Bool
pub fn ActiveCollisionTypes::test_body_types(Self, @dynamics.RigidBodyType, @dynamics.RigidBodyType) -> Bool

pub struct ActiveEvents {
  mut bits : Int
}
pub fn ActiveEvents::collision_events() -> Self
pub fn ActiveEvents::contact_force_events() -> Self
pub fn ActiveEvents::contains(Self, Self) -> Bool
pub fn ActiveEvents::empty() -> Self
pub fn ActiveEvents::insert(Self, Self) -> Self

pub struct ActiveHooks {
  mut value : Int
}
pub fn ActiveHooks::all() -> Self
pub fn ActiveHooks::contains(Self, Self) -> Bool
pub fn ActiveHooks::empty() -> Self
pub fn ActiveHooks::filter_contact_pairs() -> Self
pub fn ActiveHooks::filter_intersection_pair() -> Self
pub fn ActiveHooks::insert(Self, Self) -> Self
pub fn ActiveHooks::modify_solver_contacts() -> Self

pub struct BroadPhase3D {
  pairs : Array[(ColliderHandle3D, ColliderHandle3D)]
  prev_pairs : Array[(ColliderHandle3D, ColliderHandle3D)]
  events : Array[BroadPhasePairEvent3D]
}
pub fn BroadPhase3D::new() -> Self
pub fn BroadPhase3D::pairs(Self) -> Array[(ColliderHandle3D, ColliderHandle3D)]
pub fn BroadPhase3D::take_events(Self) -> Array[BroadPhasePairEvent3D]
pub fn BroadPhase3D::update(Self, Float, ColliderSet3D) -> Unit

pub struct BroadPhaseBvh {
  optimization_strategy : BvhOptimizationStrategy
  pairs : Array[(ColliderHandle, ColliderHandle)]
  mut events : Array[BroadPhasePairEvent]
}
pub fn BroadPhaseBvh::as_query_pipeline(Self, @dynamics.RigidBodySet, ColliderSet, QueryFilter) -> QueryPipeline
pub fn BroadPhaseBvh::as_query_pipeline_mut(Self, @dynamics.RigidBodySet, ColliderSet, QueryFilter) -> QueryPipelineMut
pub fn BroadPhaseBvh::new() -> Self
pub fn BroadPhaseBvh::pairs(Self) -> Array[(ColliderHandle, ColliderHandle)]
pub fn BroadPhaseBvh::take_events(Self) -> Array[BroadPhasePairEvent]
pub fn BroadPhaseBvh::update(Self, Float, @dynamics.RigidBodySet, ColliderSet) -> Unit
pub fn BroadPhaseBvh::with_optimization_strategy(BvhOptimizationStrategy) -> Self

pub(all) enum BroadPhasePairEvent {
  AddPair(ColliderPair)
  DeletePair(ColliderPair)
}

pub(all) enum BroadPhasePairEvent3D {
  AddPair(ColliderPair3D)
  DeletePair(ColliderPair3D)
}

pub(all) enum BvhOptimizationStrategy {
  SubtreeOptimizer
  None
}
pub fn BvhOptimizationStrategy::none() -> Self
pub fn BvhOptimizationStrategy::subtree_optimizer() -> Self

pub struct Collider {
  mut shape : Shape
  mut local_translation : @core.Vec2
  mut local_rotation : Float
  mut world_translation : @core.Vec2
  mut world_rotation : Float
  mut active_collision_types : ActiveCollisionTypes
  mut sensor : Bool
  mut active_events : ActiveEvents
  mut active_hooks : ActiveHooks
  mut collision_groups : @dynamics.InteractionGroups
  mut solver_groups : @dynamics.InteractionGroups
  mut density : Float
  mut friction : Float
  mut friction_combine_rule : @dynamics.CoefficientCombineRule
  mut restitution : Float
  mut restitution_combine_rule : @dynamics.CoefficientCombineRule
  mut contact_skin : Float
  mut contact_force_event_threshold : Float
  mut user_data : Int
  mut parent : @dynamics.RigidBodyHandle?
  mut enabled : ColliderEnabled
  mut changes : ColliderChanges
}
pub fn Collider::active_collision_types(Self) -> ActiveCollisionTypes
pub fn Collider::active_events(Self) -> ActiveEvents
pub fn Collider::active_hooks(Self) -> ActiveHooks
pub fn Collider::collision_groups(Self) -> @dynamics.InteractionGroups
pub fn Collider::contact_force_event_threshold(Self) -> Float
pub fn Collider::contact_skin(Self) -> Float
pub fn Collider::density(Self) -> Float
pub fn Collider::friction(Self) -> Float
pub fn Collider::friction_combine_rule(Self) -> @dynamics.CoefficientCombineRule
pub fn Collider::is_enabled(Self) -> Bool
pub fn Collider::is_sensor(Self) -> Bool
pub fn Collider::mass_properties(Self) -> @core.MassProperties
pub fn Collider::parent(Self) -> @dynamics.RigidBodyHandle?
pub fn Collider::position(Self) -> @core.Isometry2
pub fn Collider::position_wrt_parent(Self) -> @core.Isometry2?
pub fn Collider::restitution(Self) -> Float
pub fn Collider::restitution_combine_rule(Self) -> @dynamics.CoefficientCombineRule
pub fn Collider::rotation(Self) -> Float
pub fn Collider::set_active_collision_types(Self, ActiveCollisionTypes) -> Self
pub fn Collider::set_active_events(Self, ActiveEvents) -> Self
pub fn Collider::set_active_hooks(Self, ActiveHooks) -> Self
pub fn Collider::set_collision_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn Collider::set_contact_force_event_threshold(Self, Float) -> Self
pub fn Collider::set_contact_skin(Self, Float) -> Self
pub fn Collider::set_density(Self, Float) -> Self
pub fn Collider::set_enabled(Self, Bool) -> Self
pub fn Collider::set_friction(Self, Float) -> Self
pub fn Collider::set_friction_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn Collider::set_position(Self, @core.Isometry2) -> Self
pub fn Collider::set_restitution(Self, Float) -> Self
pub fn Collider::set_restitution_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn Collider::set_rotation(Self, Float) -> Self
pub fn Collider::set_rotation_wrt_parent(Self, Float) -> Self
pub fn Collider::set_sensor(Self, Bool) -> Self
pub fn Collider::set_shape(Self, Shape) -> Self
pub fn Collider::set_solver_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn Collider::set_translation(Self, @core.Vec2) -> Self
pub fn Collider::set_translation_wrt_parent(Self, @core.Vec2) -> Self
pub fn Collider::set_user_data(Self, Int) -> Self
pub fn Collider::shape(Self) -> Shape
pub fn Collider::solver_groups(Self) -> @dynamics.InteractionGroups
pub fn Collider::translation(Self) -> @core.Vec2
pub fn Collider::translation3(Self) -> @core.Vec3
pub fn Collider::user_data(Self) -> Int

pub struct Collider3D {
  mut position : @core.Isometry3
  mut local_position : @core.Isometry3
  mut parent : @dynamics.RigidBodyHandle?
  shape : Shape3D
  mut enabled : Bool
  sensor : Bool
  active_events : ActiveEvents
}
pub fn Collider3D::active_events(Self) -> ActiveEvents
pub fn Collider3D::compute_aabb(Self) -> @core.Aabb3
pub fn Collider3D::compute_collision_aabb(Self, Float) -> @core.Aabb3
pub fn Collider3D::enabled(Self) -> Bool
pub fn Collider3D::is_sensor(Self) -> Bool
pub fn Collider3D::local_position(Self) -> @core.Isometry3
pub fn Collider3D::parent(Self) -> @dynamics.RigidBodyHandle?
pub fn Collider3D::position(Self) -> @core.Isometry3
pub fn Collider3D::set_enabled(Self, Bool) -> Self
pub fn Collider3D::set_local_position(Self, @core.Isometry3) -> Unit
pub fn Collider3D::set_parent(Self, @dynamics.RigidBodyHandle?) -> Unit
pub fn Collider3D::set_position(Self, @core.Isometry3) -> Unit
pub fn Collider3D::shape(Self) -> Shape3D

pub struct ColliderBuilder {
  shape : Shape
  mut translation : @core.Vec2
  mut rotation : Float
  mut active_collision_types : ActiveCollisionTypes
  mut sensor : Bool
  mut active_events : ActiveEvents
  mut active_hooks : ActiveHooks
  mut collision_groups : @dynamics.InteractionGroups
  mut solver_groups : @dynamics.InteractionGroups
  mut density : Float
  mut friction : Float
  mut friction_combine_rule : @dynamics.CoefficientCombineRule
  mut restitution : Float
  mut restitution_combine_rule : @dynamics.CoefficientCombineRule
  mut contact_skin : Float
  mut contact_force_event_threshold : Float
  mut user_data : Int
  mut enabled : Bool
}
pub fn ColliderBuilder::active_collision_types(Self, ActiveCollisionTypes) -> Self
pub fn ColliderBuilder::active_events(Self, ActiveEvents) -> Self
pub fn ColliderBuilder::active_hooks(Self, ActiveHooks) -> Self
pub fn ColliderBuilder::ball(Float) -> Self
pub fn ColliderBuilder::build(Self) -> Collider
pub fn ColliderBuilder::capsule_from_endpoints(@core.Vec2, @core.Vec2, Float) -> Self
pub fn ColliderBuilder::capsule_x(Float, Float) -> Self
pub fn ColliderBuilder::capsule_y(Float, Float) -> Self
pub fn ColliderBuilder::collision_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder::compound(Array[(@core.Isometry2, Shape)]) -> Self
pub fn ColliderBuilder::contact_force_event_threshold(Self, Float) -> Self
pub fn ColliderBuilder::contact_skin(Self, Float) -> Self
pub fn ColliderBuilder::convex_hull(Array[@core.Vec2]) -> Self?
pub fn ColliderBuilder::cuboid(Float, Float) -> Self
pub fn ColliderBuilder::density(Self, Float) -> Self
pub fn ColliderBuilder::enabled(Self, Bool) -> Self
pub fn ColliderBuilder::friction(Self, Float) -> Self
pub fn ColliderBuilder::friction_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn ColliderBuilder::halfspace(@core.Vec2) -> Self
pub fn ColliderBuilder::heightfield(Array[Float], @core.Vec2) -> Self
pub fn ColliderBuilder::new(Shape) -> Self
pub fn ColliderBuilder::polyline(Array[@core.Vec2], Array[(Int, Int)]?) -> Self
pub fn ColliderBuilder::restitution(Self, Float) -> Self
pub fn ColliderBuilder::restitution_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn ColliderBuilder::rotation(Self, Float) -> Self
pub fn ColliderBuilder::round_convex_hull(Array[@core.Vec2], Float) -> Self?
pub fn ColliderBuilder::round_triangle(@core.Vec2, @core.Vec2, @core.Vec2, Float) -> Self
pub fn ColliderBuilder::segment(@core.Vec2, @core.Vec2) -> Self
pub fn ColliderBuilder::sensor(Self, Bool) -> Self
pub fn ColliderBuilder::solver_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder::translation(Self, @core.Vec2) -> Self
pub fn ColliderBuilder::triangle(@core.Vec2, @core.Vec2, @core.Vec2) -> Self
pub fn ColliderBuilder::trimesh(Array[@core.Vec2], Array[(Int, Int, Int)]) -> Self?
pub fn ColliderBuilder::user_data(Self, Int) -> Self
pub fn ColliderBuilder::voxelized_mesh(Array[@core.Vec2], Array[(Int, Int)], Float, FillMode) -> Self
pub fn ColliderBuilder::voxels_from_points(@core.Vec2, Array[@core.Vec2]) -> Self

pub struct ColliderBuilder3 {
  inner : ColliderBuilder
}
pub fn ColliderBuilder3::active_collision_types(Self, ActiveCollisionTypes) -> Self
pub fn ColliderBuilder3::active_events(Self, ActiveEvents) -> Self
pub fn ColliderBuilder3::active_hooks(Self, ActiveHooks) -> Self
pub fn ColliderBuilder3::ball(Float) -> Self
pub fn ColliderBuilder3::build(Self) -> Collider
pub fn ColliderBuilder3::capsule_x(Float, Float) -> Self
pub fn ColliderBuilder3::capsule_y(Float, Float) -> Self
pub fn ColliderBuilder3::collision_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder3::compound(Array[(@core.Isometry3, SharedShape)]) -> Self
pub fn ColliderBuilder3::cone(Float, Float) -> Self
pub fn ColliderBuilder3::contact_skin(Self, Float) -> Self
pub fn ColliderBuilder3::convex_hull(Array[@core.Vec3]) -> Self?
pub fn ColliderBuilder3::cuboid(Float, Float, Float) -> Self
pub fn ColliderBuilder3::density(Self, Float) -> Self
pub fn ColliderBuilder3::friction(Self, Float) -> Self
pub fn ColliderBuilder3::heightfield(Array[Float], @core.Vec3) -> Self
pub fn ColliderBuilder3::restitution(Self, Float) -> Self
pub fn ColliderBuilder3::rotation(Self, @core.Quat) -> Self
pub fn ColliderBuilder3::rotation_scaled_axis(Self, @core.Vec3) -> Self
pub fn ColliderBuilder3::round_convex_hull(Array[@core.Vec3], Float) -> Self?
pub fn ColliderBuilder3::round_cylinder(Float, Float, Float) -> Self
pub fn ColliderBuilder3::segment(@core.Vec3, @core.Vec3) -> Self
pub fn ColliderBuilder3::sensor(Self, Bool) -> Self
pub fn ColliderBuilder3::solver_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder3::translation(Self, @core.Vec3) -> Self
pub fn ColliderBuilder3::trimesh(Array[@core.Vec3], Array[(Int, Int, Int)]) -> Self?
pub fn ColliderBuilder3::voxelized_mesh(Array[@core.Vec3], Array[(Int, Int)], Float, FillMode) -> Self
pub fn ColliderBuilder3::voxels_from_points(@core.Vec3, Array[@core.Vec3]) -> Self

pub struct ColliderBuilder3D {
  mut position : @core.Isometry3
  mut local_position : @core.Isometry3
  parent : @dynamics.RigidBodyHandle?
  shape : Shape3D
  mut enabled : Bool
  mut sensor : Bool
  mut active_events : ActiveEvents
}
pub fn ColliderBuilder3D::active_events(Self, ActiveEvents) -> Self
pub fn ColliderBuilder3D::ball(Float) -> Self
pub fn ColliderBuilder3D::build(Self) -> Collider3D
pub fn ColliderBuilder3D::capsule_y(Float, Float) -> Self
pub fn ColliderBuilder3D::cone(Float, Float) -> Self
pub fn ColliderBuilder3D::cuboid(Float, Float, Float) -> Self
pub fn ColliderBuilder3D::cylinder(Float, Float) -> Self
pub fn ColliderBuilder3D::enabled(Self, Bool) -> Self
pub fn ColliderBuilder3D::local_position(Self, @core.Isometry3) -> Self
pub fn ColliderBuilder3D::position(Self, @core.Isometry3) -> Self
pub fn ColliderBuilder3D::rotation(Self, @core.Quat) -> Self
pub fn ColliderBuilder3D::round_cylinder(Float, Float, Float) -> Self
pub fn ColliderBuilder3D::sensor(Self, Bool) -> Self
pub fn ColliderBuilder3D::translation(Self, @core.Vec3) -> Self

type ColliderChanges

pub(all) enum ColliderEnabled {
  Enabled
  DisabledByParent
  Disabled
}

pub struct ColliderHandle {
  id : Int
  generation : Int
}
pub fn ColliderHandle::equals(Self, Self) -> Bool
pub fn ColliderHandle::from_raw_parts(Int, Int) -> Self
pub fn ColliderHandle::into_raw_parts(Self) -> (Int, Int)
pub fn ColliderHandle::invalid() -> Self

pub struct ColliderHandle3D {
  id : Int
  generation : Int
}
pub fn ColliderHandle3D::equals(Self, Self) -> Bool
pub fn ColliderHandle3D::from_raw_parts(Int, Int) -> Self
pub fn ColliderHandle3D::into_raw_parts(Self) -> (Int, Int)
pub fn ColliderHandle3D::invalid() -> Self

pub struct ColliderPair {
  collider1 : ColliderHandle
  collider2 : ColliderHandle
}
pub fn ColliderPair::collider1(Self) -> ColliderHandle
pub fn ColliderPair::collider2(Self) -> ColliderHandle
pub fn ColliderPair::new(ColliderHandle, ColliderHandle) -> Self

pub struct ColliderPair3D {
  collider1 : ColliderHandle3D
  collider2 : ColliderHandle3D
}
pub fn ColliderPair3D::collider1(Self) -> ColliderHandle3D
pub fn ColliderPair3D::collider2(Self) -> ColliderHandle3D
pub fn ColliderPair3D::new(ColliderHandle3D, ColliderHandle3D) -> Self

pub struct ColliderSet {
  colliders : Array[Collider?]
  generations : Array[Int]
  free_list : Array[Int]
  modified_colliders : Array[ColliderHandle]
}
pub fn ColliderSet::clear_changes_for(Self, Array[ColliderHandle]) -> Unit
pub fn ColliderSet::colliders_with_parent(Self, @dynamics.RigidBodyHandle) -> Array[ColliderHandle]
pub fn ColliderSet::deserialize(String) -> Self
pub fn ColliderSet::get(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::get_mut(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::get_mut_internal(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::get_mut_internal_with_modification_tracking(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::insert(Self, Collider) -> ColliderHandle
pub fn ColliderSet::insert_with_parent(Self, Collider, @dynamics.RigidBodyHandle, @dynamics.RigidBodySet) -> ColliderHandle
pub fn ColliderSet::is_empty(Self) -> Bool
pub fn ColliderSet::len(Self) -> Int
pub fn ColliderSet::new() -> Self
pub fn ColliderSet::remove(Self, ColliderHandle, @dynamics.IslandManager, @dynamics.RigidBodySet, Bool) -> Unit
pub fn ColliderSet::serialize(Self) -> String
pub fn ColliderSet::set_parent(Self, ColliderHandle, @dynamics.RigidBodyHandle?, @dynamics.RigidBodySet) -> Unit
pub fn ColliderSet::set_parent_enabled(Self, @dynamics.RigidBodyHandle, Bool) -> Unit
pub fn ColliderSet::take_modified(Self) -> Array[ColliderHandle]

pub struct ColliderSet3 {
  inner : ColliderSet
}
pub fn ColliderSet3::as_2d(Self) -> ColliderSet
pub fn ColliderSet3::get(Self, ColliderHandle) -> Collider?
pub fn ColliderSet3::insert(Self, Collider) -> ColliderHandle
pub fn ColliderSet3::insert_with_parent(Self, Collider, @dynamics.RigidBodyHandle, @dynamics.RigidBodySet3) -> ColliderHandle
pub fn ColliderSet3::len(Self) -> Int
pub fn ColliderSet3::new() -> Self
pub fn ColliderSet3::remove(Self, ColliderHandle, @dynamics.IslandManager3, @dynamics.RigidBodySet3, Bool) -> Unit
pub fn ColliderSet3::set_parent(Self, ColliderHandle, @dynamics.RigidBodyHandle?, @dynamics.RigidBodySet3) -> Unit

pub struct ColliderSet3D {
  colliders : Array[Collider3D?]
  generations : Array[Int]
  free_list : Array[Int]
}
pub fn ColliderSet3D::get(Self, ColliderHandle3D) -> Collider3D?
pub fn ColliderSet3D::get_mut(Self, ColliderHandle3D) -> Collider3D?
pub fn ColliderSet3D::insert(Self, Collider3D) -> ColliderHandle3D
pub fn ColliderSet3D::insert_with_parent(Self, Collider3D, @dynamics.RigidBodyHandle, @dynamics.RigidBodySet3D) -> ColliderHandle3D
pub fn ColliderSet3D::len(Self) -> Int
pub fn ColliderSet3D::new() -> Self
pub fn ColliderSet3D::remove(Self, ColliderHandle3D) -> Collider3D?
pub fn ColliderSet3D::set_parent(Self, ColliderHandle3D, @dynamics.RigidBodyHandle?, @dynamics.RigidBodySet3D) -> Unit
pub fn ColliderSet3D::sync_with_bodies(Self, @dynamics.RigidBodySet3D) -> Unit

pub(all) enum CollisionEvent {
  Started(ColliderHandle, ColliderHandle, CollisionEventFlags)
  Stopped(ColliderHandle, ColliderHandle, CollisionEventFlags)
}
pub fn CollisionEvent::collider1(Self) -> ColliderHandle
pub fn CollisionEvent::collider2(Self) -> ColliderHandle
pub fn CollisionEvent::removed(Self) -> Bool
pub fn CollisionEvent::sensor(Self) -> Bool
pub fn CollisionEvent::started(Self) -> Bool
pub fn CollisionEvent::stopped(Self) -> Bool

pub(all) enum CollisionEvent3D {
  Started(ColliderHandle3D, ColliderHandle3D, CollisionEventFlags)
  Stopped(ColliderHandle3D, ColliderHandle3D, CollisionEventFlags)
}
pub fn CollisionEvent3D::collider1(Self) -> ColliderHandle3D
pub fn CollisionEvent3D::collider2(Self) -> ColliderHandle3D
pub fn CollisionEvent3D::removed(Self) -> Bool
pub fn CollisionEvent3D::sensor(Self) -> Bool
pub fn CollisionEvent3D::started(Self) -> Bool
pub fn CollisionEvent3D::stopped(Self) -> Bool

pub struct CollisionEventFlags {
  mut bits : Int
}
pub fn CollisionEventFlags::contains(Self, Self) -> Bool
pub fn CollisionEventFlags::empty() -> Self
pub fn CollisionEventFlags::insert(Self, Self) -> Self
pub fn CollisionEventFlags::removed() -> Self
pub fn CollisionEventFlags::sensor() -> Self

pub struct ContactForceEvent {
  collider1 : ColliderHandle
  collider2 : ColliderHandle
  total_force : @core.Vec2
  total_force_magnitude : Float
  max_force_direction : @core.Vec2
  max_force_magnitude : Float
}
pub fn ContactForceEvent::collider1(Self) -> ColliderHandle
pub fn ContactForceEvent::collider2(Self) -> ColliderHandle
pub fn ContactForceEvent::max_force_direction(Self) -> @core.Vec2
pub fn ContactForceEvent::max_force_magnitude(Self) -> Float
pub fn ContactForceEvent::new(ColliderHandle, ColliderHandle, @core.Vec2, Float, @core.Vec2, Float) -> Self
pub fn ContactForceEvent::total_force(Self) -> @core.Vec2
pub fn ContactForceEvent::total_force_magnitude(Self) -> Float

pub struct ContactManifold {
  normal : @core.Vec2
  points : Array[ContactManifoldPoint]
}
pub fn ContactManifold::normal(Self) -> @core.Vec2
pub fn ContactManifold::points(Self) -> Array[ContactManifoldPoint]

pub struct ContactManifoldPoint {
  local_p1 : @core.Vec2
  local_p2 : @core.Vec2
  dist : Float
  fid1 : FeatureId
  fid2 : FeatureId
}
pub fn ContactManifoldPoint::dist(Self) -> Float
pub fn ContactManifoldPoint::fid1(Self) -> FeatureId
pub fn ContactManifoldPoint::fid2(Self) -> FeatureId
pub fn ContactManifoldPoint::local_p1(Self) -> @core.Vec2
pub fn ContactManifoldPoint::local_p2(Self) -> @core.Vec2

pub struct ContactPair {
  manifolds : Array[ContactManifold]
}
pub fn ContactPair::manifold_count(Self) -> Int
pub fn ContactPair::manifolds(Self) -> Array[ContactManifold]

pub struct ContactPair3D {
  manifolds : Array[ContactPoint3D]
}
pub fn ContactPair3D::manifolds(Self) -> Array[ContactPoint3D]
pub fn ContactPair3D::manifolds_len(Self) -> Int

pub struct ContactPoint3D {
  point1 : @core.Vec3
  point2 : @core.Vec3
  normal : @core.Vec3
  penetration : Float
}

pub(all) enum FeatureId {
  Unknown
  Vertex(Int)
  Edge(Int)
  Face(Int)
}

pub(all) enum FillMode {
  SurfaceOnly
  FloodFill(Bool, Bool)
}
pub fn FillMode::default() -> Self
pub fn FillMode::surface_only() -> Self

pub struct HeightField {
  heights : Array[Float]
  scale : @core.Vec2
}
pub fn HeightField::as_shape(Self) -> Shape
pub fn HeightField::new(Array[Float], @core.Vec2) -> Self

pub struct IntersectionPair {
  collider1 : ColliderHandle
  collider2 : ColliderHandle
  intersecting : Bool
}

pub(all) enum MeshConverter {
  TriMesh
  Aabb
  Obb
  ConvexHull
  ConvexDecomposition
}
pub fn MeshConverter::aabb() -> Self
pub fn MeshConverter::apply(Self, Array[@core.Vec2], Array[(Int, Int, Int)]) -> Result[(SharedShape, @core.Isometry2), MeshConverterError]
pub fn MeshConverter::convex_hull() -> Self
pub fn MeshConverter::obb() -> Self
pub fn MeshConverter::trimesh() -> Self

pub(all) enum MeshConverterError {
  ConvexHullFailed
  TriMeshBuilderError
  EmptyVertices
}
pub fn MeshConverterError::to_string(Self) -> String

pub struct NarrowPhase {
  mut intersections : Array[IntersectionPair]
  mut contacts : Array[(ColliderHandle, ColliderHandle, ContactPair)]
}
pub fn NarrowPhase::contact_pair(Self, ColliderHandle, ColliderHandle) -> ContactPair?
pub fn NarrowPhase::contact_pairs(Self) -> Array[(ColliderHandle, ColliderHandle, ContactPair)]
pub fn NarrowPhase::contact_pairs_with(Self, ColliderHandle) -> Array[(ColliderHandle, ColliderHandle, ContactPair)]
pub fn NarrowPhase::intersection_pair(Self, ColliderHandle, ColliderHandle) -> IntersectionPair?
pub fn NarrowPhase::intersection_pairs(Self) -> Array[IntersectionPair]
pub fn NarrowPhase::intersection_pairs_with(Self, ColliderHandle) -> Array[IntersectionPair]
pub fn NarrowPhase::new() -> Self
pub fn NarrowPhase::update(Self, @dynamics.RigidBodySet, ColliderSet, @dynamics.ImpulseJointSet, @dynamics.MultibodyJointSet) -> Unit
pub fn NarrowPhase::update_with_pairs(Self, @dynamics.RigidBodySet, ColliderSet, Float, Array[(ColliderHandle, ColliderHandle)], @dynamics.ImpulseJointSet, @dynamics.MultibodyJointSet) -> Unit

pub struct NarrowPhase3D {
  contact_pairs : Array[((ColliderHandle3D, ColliderHandle3D), ContactPair3D)]
}
pub fn NarrowPhase3D::all_contact_pairs(Self) -> Array[((ColliderHandle3D, ColliderHandle3D), ContactPair3D)]
pub fn NarrowPhase3D::clear(Self) -> Unit
pub fn NarrowPhase3D::contact_pair(Self, ColliderHandle3D, ColliderHandle3D) -> ContactPair3D?
pub fn NarrowPhase3D::intersection_pair(Self, ColliderHandle3D, ColliderHandle3D) -> Unit?
pub fn NarrowPhase3D::new() -> Self
pub fn NarrowPhase3D::update(Self, Array[(ColliderHandle3D, ColliderHandle3D)], @dynamics.RigidBodySet3D, ColliderSet3D) -> Unit

pub struct NonlinearRigidMotion {
  start_pos : @core.Isometry2
  linvel : @core.Vec2
  angvel : Float
}
pub fn NonlinearRigidMotion::identity() -> Self
pub fn NonlinearRigidMotion::new(@core.Isometry2, @core.Vec2, Float) -> Self

pub struct PointProjection {
  point : @core.Vec2
  is_inside : Bool
}
pub fn PointProjection::is_inside(Self) -> Bool
pub fn PointProjection::point(Self) -> @core.Vec2

pub struct QueryFilter {
  excluded_body : @dynamics.RigidBodyHandle?
  excluded_collider : ColliderHandle?
  mut groups : @dynamics.InteractionGroups?
  mut flags : QueryFilterFlags
  mut predicate : ((ColliderHandle, Collider) -> Bool)?
}
pub fn QueryFilter::exclude_collider(Self, ColliderHandle) -> Self
pub fn QueryFilter::exclude_dynamic(Self) -> Self
pub fn QueryFilter::exclude_fixed(Self) -> Self
pub fn QueryFilter::exclude_kinematic(Self) -> Self
pub fn QueryFilter::exclude_rigid_body(Self, @dynamics.RigidBodyHandle) -> Self
pub fn QueryFilter::exclude_sensors(Self) -> Self
pub fn QueryFilter::exclude_solids(Self) -> Self
pub fn QueryFilter::groups(Self, @dynamics.InteractionGroups) -> Self
pub fn QueryFilter::groups_filter(Self) -> @dynamics.InteractionGroups?
pub fn QueryFilter::new() -> Self
pub fn QueryFilter::only_dynamic() -> Self
pub fn QueryFilter::only_fixed() -> Self
pub fn QueryFilter::only_kinematic() -> Self
pub fn QueryFilter::predicate(Self, (ColliderHandle, Collider) -> Bool) -> Self

pub struct QueryFilterFlags {
  mut bits : Int
}
pub fn QueryFilterFlags::contains(Self, Int) -> Bool
pub fn QueryFilterFlags::empty() -> Self
pub fn QueryFilterFlags::insert(Self, Int) -> Self
pub fn QueryFilterFlags::new(Int) -> Self

pub struct QueryPipeline {
  filter : QueryFilter
  bodies : @dynamics.RigidBodySet
  colliders : ColliderSet
  aabbs : Array[@core.Aabb?]
}
pub fn QueryPipeline::cast_ray(Self, Ray, Float, Bool) -> (ColliderHandle, Float)?
pub fn QueryPipeline::cast_ray_and_get_normal(Self, Ray, Float, Bool) -> (ColliderHandle, RayIntersection)?
pub fn QueryPipeline::cast_shape(Self, @core.Isometry2, @core.Vec2, Shape, ShapeCastOptions) -> (ColliderHandle, ShapeCastHit)?
pub fn QueryPipeline::cast_shape_nonlinear(Self, NonlinearRigidMotion, Shape, Float, Float, Bool) -> (ColliderHandle, ShapeCastHit)?
pub fn QueryPipeline::collider(Self, ColliderHandle) -> Collider?
pub fn QueryPipeline::intersect_aabb_conservative(Self, @core.Aabb) -> Array[ColliderHandle]
pub fn QueryPipeline::intersect_point(Self, @core.Vec2) -> Array[ColliderHandle]
pub fn QueryPipeline::intersect_ray(Self, Ray, Float, Bool) -> Array[(ColliderHandle, RayIntersection)]
pub fn QueryPipeline::intersect_shape(Self, @core.Isometry2, Shape) -> Array[ColliderHandle]
pub fn QueryPipeline::new(QueryFilter, @dynamics.RigidBodySet, ColliderSet) -> Self
pub fn QueryPipeline::new3(QueryFilter, @dynamics.RigidBodySet3, ColliderSet3) -> Self
pub fn QueryPipeline::project_point(Self, @core.Vec2, Float, Bool) -> (ColliderHandle, PointProjection)?
pub fn QueryPipeline::project_point_and_get_feature(Self, @core.Vec2, Float, Bool) -> (ColliderHandle, PointProjection, FeatureId)?
pub fn QueryPipeline::rigid_body(Self, @dynamics.RigidBodyHandle) -> @dynamics.RigidBody?
pub fn QueryPipeline::update(Self) -> Unit
pub fn QueryPipeline::with_filter(Self, QueryFilter) -> Self

pub struct QueryPipelineMut {
  pipeline : QueryPipeline
}
pub fn QueryPipelineMut::as_ref(Self) -> QueryPipeline
pub fn QueryPipelineMut::new(QueryFilter, @dynamics.RigidBodySet, ColliderSet) -> Self
pub fn QueryPipelineMut::new3(QueryFilter, @dynamics.RigidBodySet3, ColliderSet3) -> Self
pub fn QueryPipelineMut::update(Self) -> Unit

pub struct Ray {
  origin : @core.Vec2
  dir : @core.Vec2
}
pub fn Ray::new(@core.Vec2, @core.Vec2) -> Self

pub struct RayIntersection {
  toi : Float
  normal : @core.Vec2
}
pub fn RayIntersection::normal(Self) -> @core.Vec2
pub fn RayIntersection::toi(Self) -> Float

pub(all) enum Shape {
  Ball(Float)
  Cuboid(Float, Float)
  CapsuleX(Float, Float)
  CapsuleY(Float, Float)
  Segment(@core.Vec2, @core.Vec2)
  Polyline(Array[@core.Vec2], Array[(Int, Int)]?)
  ConvexPolygon(Array[@core.Vec2])
  TriMesh(Array[@core.Vec2], Array[(Int, Int, Int)])
  Compound(Array[(@core.Isometry2, Shape)])
}
pub fn Shape::voxelized_mesh(Array[@core.Vec2], Array[(Int, Int)], Float, FillMode) -> Self

pub(all) enum Shape3D {
  Ball(Float)
  Cuboid(@core.Vec3)
  CapsuleY(Float, Float)
  Cylinder(Float, Float)
  RoundCylinder(Float, Float, Float)
  Cone(Float, Float)
}
pub fn Shape3D::ball(Float) -> Self
pub fn Shape3D::capsule_y(Float, Float) -> Self
pub fn Shape3D::cone(Float, Float) -> Self
pub fn Shape3D::cuboid(Float, Float, Float) -> Self
pub fn Shape3D::cylinder(Float, Float) -> Self
pub fn Shape3D::local_aabb(Self) -> @core.Aabb3
pub fn Shape3D::round_cylinder(Float, Float, Float) -> Self

pub struct ShapeCastHit {
  toi : Float
  point : @core.Vec2
  normal : @core.Vec2
}
pub fn ShapeCastHit::normal(Self) -> @core.Vec2
pub fn ShapeCastHit::point(Self) -> @core.Vec2
pub fn ShapeCastHit::toi(Self) -> Float

pub struct ShapeCastOptions {
  max_toi : Float
  target_distance : Float
  stop_at_penetration : Bool
}
pub fn ShapeCastOptions::max_toi(Self) -> Float
pub fn ShapeCastOptions::new(Float, Bool) -> Self
pub fn ShapeCastOptions::stop_at_penetration(Self) -> Bool
pub fn ShapeCastOptions::target_distance(Self) -> Float
pub fn ShapeCastOptions::with_target_distance(Self, Float) -> Self

pub struct SharedShape {
  shape : Shape
}
pub fn SharedShape::as_shape(Self) -> Shape
pub fn SharedShape::ball(Float) -> Self
pub fn SharedShape::capsule_x(Float, Float) -> Self
pub fn SharedShape::capsule_y(Float, Float) -> Self
pub fn SharedShape::cuboid(Float, Float) -> Self
pub fn SharedShape::heightfield(Array[Float], @core.Vec2) -> Self
pub fn SharedShape::new(Shape) -> Self
pub fn SharedShape::polyline(Array[@core.Vec2], Array[(Int, Int)]?) -> Self
pub fn SharedShape::segment(@core.Vec2, @core.Vec2) -> Self
pub fn SharedShape::triangle(@core.Vec2, @core.Vec2, @core.Vec2) -> Self
pub fn SharedShape::trimesh(Array[@core.Vec2], Array[(Int, Int, Int)]) -> Self?

pub struct SolverContact {
  mut point : @core.Vec2
  mut dist : Float
  mut friction : Float
  mut restitution : Float
  mut tangent_velocity : @core.Vec2
}
pub fn SolverContact::dist(Self) -> Float
pub fn SolverContact::friction(Self) -> Float
pub fn SolverContact::new(@core.Vec2, Float) -> Self
pub fn SolverContact::point(Self) -> @core.Vec2
pub fn SolverContact::restitution(Self) -> Float
pub fn SolverContact::set_dist(Self, Float) -> Unit
pub fn SolverContact::set_friction(Self, Float) -> Unit
pub fn SolverContact::set_point(Self, @core.Vec2) -> Unit
pub fn SolverContact::set_restitution(Self, Float) -> Unit
pub fn SolverContact::set_tangent_velocity(Self, @core.Vec2) -> Unit
pub fn SolverContact::tangent_velocity(Self) -> @core.Vec2

pub struct SolverFlags {
  mut value : Int
}
pub fn SolverFlags::compute_impulses() -> Self
pub fn SolverFlags::contains(Self, Self) -> Bool
pub fn SolverFlags::default() -> Self
pub fn SolverFlags::empty() -> Self
pub fn SolverFlags::insert(Self, Self) -> Self
pub fn SolverFlags::remove(Self, Self) -> Self

pub struct Triangle {
  a : @core.Vec2
  b : @core.Vec2
  c : @core.Vec2
}
pub fn Triangle::as_shape(Self) -> Shape
pub fn Triangle::new(@core.Vec2, @core.Vec2, @core.Vec2) -> Self

// Type aliases

// Traits

