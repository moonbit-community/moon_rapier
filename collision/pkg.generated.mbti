// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_rapier/collision"

import {
  "Milky2018/moon_rapier/core",
  "Milky2018/moon_rapier/dynamics",
  "moonbitlang/core/hashmap",
}

// Values
pub const DYNAMIC_DYNAMIC : Int = 0x0001

pub const DYNAMIC_FIXED : Int = 0x0002

pub const DYNAMIC_KINEMATIC : Int = 0x000C

pub const ENABLED_OR_DISABLED : Int = 256

pub const FIXED_FIXED : Int = 0x0020

pub const GROUPS : Int = 16

pub const IN_MODIFIED_SET : Int = 1

pub const KINEMATIC_FIXED : Int = 0x2200

pub const KINEMATIC_KINEMATIC : Int = 0xCC00

pub const LOCAL_MASS_PROPERTIES : Int = 2

pub const PARENT : Int = 4

pub const PARENT_EFFECTIVE_DOMINANCE : Int = 128

pub const POSITION : Int = 8

pub const SHAPE : Int = 32

pub const TYPE : Int = 64

pub fn compute_ball_ball_contact(@core.Vec3, Float, @core.Vec3, Float) -> ContactPoint3D?

pub fn compute_ball_capsule_contact(@core.Vec3, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_ball_cone_contact(@core.Vec3, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_ball_cuboid_contact(@core.Vec3, Float, @core.Isometry3, @core.Vec3) -> ContactPoint3D?

pub fn compute_ball_cylinder_contact(@core.Vec3, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_ball_heightfield_contact(@core.Vec3, Float, @core.Isometry3, Array[@core.Vec3], Int, Int) -> ContactPoint3D?

pub fn compute_ball_trimesh_contact(@core.Vec3, Float, @core.Isometry3, Array[@core.Vec3], Array[(Int, Int, Int)]) -> ContactPoint3D?

pub fn compute_ball_voxels_contact(@core.Vec3, Float, @core.Isometry3, Voxels3DReal) -> ContactPoint3D?

pub fn compute_capsule_capsule_contact(@core.Isometry3, Float, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_capsule_cuboid_contact(@core.Isometry3, Float, Float, @core.Isometry3, @core.Vec3) -> ContactPoint3D?

pub fn compute_capsule_heightfield_contact(@core.Isometry3, Float, Float, @core.Isometry3, Array[@core.Vec3], Int, Int) -> ContactPoint3D?

pub fn compute_capsule_trimesh_contact(@core.Isometry3, Float, Float, @core.Isometry3, Array[@core.Vec3], Array[(Int, Int, Int)]) -> ContactPoint3D?

pub fn compute_capsule_voxels_contact(@core.Isometry3, Float, Float, @core.Isometry3, Voxels3DReal) -> ContactPoint3D?

pub fn compute_cone_cone_contact(@core.Isometry3, Float, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_cone_cuboid_contact(@core.Isometry3, Float, Float, @core.Isometry3, @core.Vec3) -> ContactPoint3D?

pub fn compute_cone_cylinder_contact(@core.Isometry3, Float, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_cone_heightfield_contact(@core.Isometry3, Float, Float, @core.Isometry3, Array[@core.Vec3], Int, Int) -> ContactPoint3D?

pub fn compute_cone_trimesh_contact(@core.Isometry3, Float, Float, @core.Isometry3, Array[@core.Vec3], Array[(Int, Int, Int)]) -> ContactPoint3D?

pub fn compute_cone_voxels_contact(@core.Isometry3, Float, Float, @core.Isometry3, Voxels3DReal) -> ContactPoint3D?

pub fn compute_convex_contact(@core.Isometry3, Shape3D, @core.Isometry3, Shape3D) -> ContactPoint3D?

pub fn compute_cuboid_cuboid_contact(@core.Isometry3, @core.Vec3, @core.Isometry3, @core.Vec3) -> ContactPoint3D?

pub fn compute_cuboid_heightfield_contact(@core.Isometry3, @core.Vec3, @core.Isometry3, Array[@core.Vec3], Int, Int) -> ContactPoint3D?

pub fn compute_cuboid_trimesh_contact(@core.Isometry3, @core.Vec3, @core.Isometry3, Array[@core.Vec3], Array[(Int, Int, Int)]) -> ContactPoint3D?

pub fn compute_cuboid_voxels_contact(@core.Isometry3, @core.Vec3, @core.Isometry3, Voxels3DReal) -> ContactPoint3D?

pub fn compute_cylinder_cuboid_contact(@core.Isometry3, Float, Float, @core.Isometry3, @core.Vec3) -> ContactPoint3D?

pub fn compute_cylinder_cylinder_contact(@core.Isometry3, Float, Float, @core.Isometry3, Float, Float) -> ContactPoint3D?

pub fn compute_cylinder_heightfield_contact(@core.Isometry3, Float, Float, @core.Isometry3, Array[@core.Vec3], Int, Int) -> ContactPoint3D?

pub fn compute_cylinder_trimesh_contact(@core.Isometry3, Float, Float, @core.Isometry3, Array[@core.Vec3], Array[(Int, Int, Int)]) -> ContactPoint3D?

pub fn compute_cylinder_voxels_contact(@core.Isometry3, Float, Float, @core.Isometry3, Voxels3DReal) -> ContactPoint3D?

pub fn compute_halfspace_contact(@core.Isometry3, @core.Vec3, @core.Isometry3, Shape3D) -> ContactPoint3D?

pub fn compute_round_cylinder_heightfield_contact(@core.Isometry3, Float, Float, Float, @core.Isometry3, Array[@core.Vec3], Int, Int) -> ContactPoint3D?

pub fn compute_round_cylinder_trimesh_contact(@core.Isometry3, Float, Float, Float, @core.Isometry3, Array[@core.Vec3], Array[(Int, Int, Int)]) -> ContactPoint3D?

pub fn handle_user_changes_to_colliders(@dynamics.RigidBodySet, ColliderSet, Array[ColliderHandle]) -> Unit

pub fn heightfield_closest_point_query(@core.Vec3, @core.Isometry3, Array[@core.Vec3], Int, Int) -> (@core.Vec3, @core.Vec3, Float)?

pub fn trimesh_closest_point_query(@core.Vec3, @core.Isometry3, Array[@core.Vec3], Array[(Int, Int, Int)]) -> (@core.Vec3, @core.Vec3, Float)?

// Errors

// Types and methods
pub struct ActiveCollisionTypes {
  value : Int
}
pub fn ActiveCollisionTypes::all() -> Self
pub fn ActiveCollisionTypes::default() -> Self
pub fn ActiveCollisionTypes::equals(Self, Self) -> Bool
pub fn ActiveCollisionTypes::test_body_types(Self, @dynamics.RigidBodyType, @dynamics.RigidBodyType) -> Bool

pub struct ActiveEvents {
  mut bits : Int
}
pub fn ActiveEvents::collision_events() -> Self
pub fn ActiveEvents::complement(Self) -> Self
pub fn ActiveEvents::contact_force_events() -> Self
pub fn ActiveEvents::contains(Self, Self) -> Bool
pub fn ActiveEvents::difference(Self, Self) -> Self
pub fn ActiveEvents::empty() -> Self
pub fn ActiveEvents::from_bits(Int) -> Self?
pub fn ActiveEvents::from_bits_retain(Int) -> Self
pub fn ActiveEvents::from_bits_truncate(Int) -> Self
pub fn ActiveEvents::from_name(String) -> Self?
pub fn ActiveEvents::insert(Self, Self) -> Self
pub fn ActiveEvents::intersection_events() -> Self
pub fn ActiveEvents::is_all(Self) -> Bool
pub fn ActiveEvents::iter_names(Self) -> Array[String]
pub fn ActiveEvents::symmetric_difference(Self, Self) -> Self
pub fn ActiveEvents::toggle(Self, Self) -> Self
pub fn ActiveEvents::union(Self, Self) -> Self

pub struct ActiveHooks {
  mut value : Int
}
pub fn ActiveHooks::all() -> Self
pub fn ActiveHooks::complement(Self) -> Self
pub fn ActiveHooks::contains(Self, Self) -> Bool
pub fn ActiveHooks::difference(Self, Self) -> Self
pub fn ActiveHooks::empty() -> Self
pub fn ActiveHooks::filter_contact_pairs() -> Self
pub fn ActiveHooks::filter_intersection_pair() -> Self
pub fn ActiveHooks::from_bits(Int) -> Self?
pub fn ActiveHooks::from_bits_retain(Int) -> Self
pub fn ActiveHooks::from_bits_truncate(Int) -> Self
pub fn ActiveHooks::from_name(String) -> Self?
pub fn ActiveHooks::insert(Self, Self) -> Self
pub fn ActiveHooks::is_all(Self) -> Bool
pub fn ActiveHooks::iter_names(Self) -> Array[String]
pub fn ActiveHooks::modify_solver_contacts() -> Self
pub fn ActiveHooks::symmetric_difference(Self, Self) -> Self
pub fn ActiveHooks::toggle(Self, Self) -> Self
pub fn ActiveHooks::union(Self, Self) -> Self

pub struct BroadPhase3D {
  pairs : Array[(ColliderHandle3D, ColliderHandle3D)]
  prev_pairs : Array[(ColliderHandle3D, ColliderHandle3D)]
  events : Array[BroadPhasePairEvent3D]
}
pub fn BroadPhase3D::new() -> Self
pub fn BroadPhase3D::pairs(Self) -> Array[(ColliderHandle3D, ColliderHandle3D)]
pub fn BroadPhase3D::take_events(Self) -> Array[BroadPhasePairEvent3D]
pub fn BroadPhase3D::update(Self, Float, ColliderSet3D) -> Unit

#alias(DefaultBroadPhase)
pub struct BroadPhaseBvh {
  optimization_strategy : BvhOptimizationStrategy
  pairs : Array[(ColliderHandle, ColliderHandle)]
  mut events : Array[BroadPhasePairEvent]
  override_aabbs : Array[(ColliderHandle, @core.Aabb)]
}
pub fn BroadPhaseBvh::as_query_pipeline(Self, @dynamics.RigidBodySet, ColliderSet, QueryFilter) -> QueryPipeline
pub fn BroadPhaseBvh::as_query_pipeline_mut(Self, @dynamics.RigidBodySet, ColliderSet, QueryFilter) -> QueryPipelineMut
pub fn BroadPhaseBvh::new() -> Self
pub fn BroadPhaseBvh::pairs(Self) -> Array[(ColliderHandle, ColliderHandle)]
pub fn BroadPhaseBvh::set_aabb(Self, ColliderHandle, @core.Aabb) -> Unit
pub fn BroadPhaseBvh::take_events(Self) -> Array[BroadPhasePairEvent]
pub fn BroadPhaseBvh::update(Self, Float, @dynamics.RigidBodySet, ColliderSet) -> Unit
pub fn BroadPhaseBvh::with_optimization_strategy(BvhOptimizationStrategy) -> Self

pub(all) enum BroadPhasePairEvent {
  AddPair(ColliderPair)
  DeletePair(ColliderPair)
}

pub(all) enum BroadPhasePairEvent3D {
  AddPair(ColliderPair3D)
  DeletePair(ColliderPair3D)
}

pub struct Bvh {
  aabbs : Array[@core.Aabb?]
}
pub fn Bvh::aabbs(Self) -> Array[@core.Aabb?]
pub fn Bvh::new(Array[@core.Aabb?]) -> Self

pub(all) enum BvhOptimizationStrategy {
  SubtreeOptimizer
  None
}
pub fn BvhOptimizationStrategy::none() -> Self
pub fn BvhOptimizationStrategy::subtree_optimizer() -> Self

pub struct Collider {
  mut shape : Shape
  mut local_translation : @core.Vec2
  mut local_rotation : Float
  mut world_translation : @core.Vec2
  mut world_rotation : Float
  mut active_collision_types : ActiveCollisionTypes
  mut sensor : Bool
  mut active_events : ActiveEvents
  mut active_hooks : ActiveHooks
  mut collision_groups : @dynamics.InteractionGroups
  mut solver_groups : @dynamics.InteractionGroups
  mut density : Float
  mut mass_properties_override : @core.MassProperties?
  mut friction : Float
  mut friction_combine_rule : @dynamics.CoefficientCombineRule
  mut restitution : Float
  mut restitution_combine_rule : @dynamics.CoefficientCombineRule
  mut contact_skin : Float
  mut contact_force_event_threshold : Float
  mut user_data : @core.UserData128
  mut parent : @dynamics.RigidBodyHandle?
  mut enabled : ColliderEnabled
  mut changes : ColliderChanges
}
pub fn Collider::active_collision_types(Self) -> ActiveCollisionTypes
pub fn Collider::active_events(Self) -> ActiveEvents
pub fn Collider::active_hooks(Self) -> ActiveHooks
pub fn Collider::collision_groups(Self) -> @dynamics.InteractionGroups
pub fn Collider::compute_broad_phase_aabb(Self, @dynamics.IntegrationParameters, @dynamics.RigidBodySet) -> @core.Aabb
pub fn Collider::compute_swept_aabb(Self, @core.Isometry2) -> @core.Aabb
pub fn Collider::contact_force_event_threshold(Self) -> Float
pub fn Collider::contact_skin(Self) -> Float
pub fn Collider::copy_from(Self, Self) -> Unit
pub fn Collider::density(Self) -> Float
pub fn Collider::friction(Self) -> Float
pub fn Collider::friction_combine_rule(Self) -> @dynamics.CoefficientCombineRule
pub fn Collider::is_enabled(Self) -> Bool
pub fn Collider::is_sensor(Self) -> Bool
pub fn Collider::mass_properties(Self) -> @core.MassProperties
pub fn Collider::material(Self) -> ColliderMaterial
pub fn Collider::parent(Self) -> @dynamics.RigidBodyHandle?
pub fn Collider::position(Self) -> @core.Isometry2
pub fn Collider::position_wrt_parent(Self) -> @core.Isometry2?
pub fn Collider::restitution(Self) -> Float
pub fn Collider::restitution_combine_rule(Self) -> @dynamics.CoefficientCombineRule
pub fn Collider::rotation(Self) -> Float
pub fn Collider::set_active_collision_types(Self, ActiveCollisionTypes) -> Self
pub fn Collider::set_active_events(Self, ActiveEvents) -> Self
pub fn Collider::set_active_hooks(Self, ActiveHooks) -> Self
pub fn Collider::set_collision_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn Collider::set_contact_force_event_threshold(Self, Float) -> Self
pub fn Collider::set_contact_skin(Self, Float) -> Self
pub fn Collider::set_density(Self, Float) -> Self
pub fn Collider::set_enabled(Self, Bool) -> Self
pub fn Collider::set_friction(Self, Float) -> Self
pub fn Collider::set_friction_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn Collider::set_mass_properties(Self, @core.MassProperties) -> Self
pub fn Collider::set_position(Self, @core.Isometry2) -> Self
pub fn Collider::set_position_wrt_parent(Self, @core.Isometry2) -> Self
pub fn Collider::set_restitution(Self, Float) -> Self
pub fn Collider::set_restitution_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn Collider::set_rotation(Self, Float) -> Self
pub fn Collider::set_rotation_wrt_parent(Self, Float) -> Self
pub fn Collider::set_sensor(Self, Bool) -> Self
pub fn Collider::set_shape(Self, Shape) -> Self
pub fn Collider::set_solver_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn Collider::set_translation(Self, @core.Vec2) -> Self
pub fn Collider::set_translation_wrt_parent(Self, @core.Vec2) -> Self
pub fn Collider::set_user_data(Self, Int) -> Self
pub fn Collider::set_user_data128(Self, @core.UserData128) -> Self
pub fn Collider::shape(Self) -> Shape
pub fn Collider::shape_mut(Self) -> Shape
pub fn Collider::shared_shape(Self) -> SharedShape
pub fn Collider::solver_groups(Self) -> @dynamics.InteractionGroups
pub fn Collider::translation(Self) -> @core.Vec2
pub fn Collider::translation3(Self) -> @core.Vec3
pub fn Collider::user_data(Self) -> Int
pub fn Collider::user_data128(Self) -> @core.UserData128
pub fn Collider::volume(Self) -> Float

pub struct Collider3D {
  mut position : @core.Isometry3
  mut local_position : @core.Isometry3
  mut parent : @dynamics.RigidBodyHandle?
  mut shape : Shape3D
  voxel_tri_map : Array[(Int, Int, Int)]?
  mut enabled : Bool
  sensor : Bool
  mut surface_velocity : @core.Vec3
  mut one_way_offset : Float?
  mut one_way_direction : Int
  active_events : ActiveEvents
  mut contact_force_event_threshold : Float
  mut user_data : @core.UserData128
  collision_groups : @dynamics.InteractionGroups
  friction : Float
  restitution : Float
}
pub fn Collider3D::active_events(Self) -> ActiveEvents
pub fn Collider3D::clear_one_way(Self) -> Unit
pub fn Collider3D::collision_groups(Self) -> @dynamics.InteractionGroups
pub fn Collider3D::compute_aabb(Self) -> @core.Aabb3
pub fn Collider3D::compute_collision_aabb(Self, Float) -> @core.Aabb3
pub fn Collider3D::contact_force_event_threshold(Self) -> Float
pub fn Collider3D::enabled(Self) -> Bool
pub fn Collider3D::friction(Self) -> Float
pub fn Collider3D::is_sensor(Self) -> Bool
pub fn Collider3D::local_position(Self) -> @core.Isometry3
pub fn Collider3D::one_way(Self) -> (Float, Int)?
pub fn Collider3D::parent(Self) -> @dynamics.RigidBodyHandle?
pub fn Collider3D::position(Self) -> @core.Isometry3
pub fn Collider3D::restitution(Self) -> Float
pub fn Collider3D::set_contact_force_event_threshold(Self, Float) -> Self
pub fn Collider3D::set_enabled(Self, Bool) -> Self
pub fn Collider3D::set_local_position(Self, @core.Isometry3) -> Unit
pub fn Collider3D::set_one_way_above(Self, Float) -> Unit
pub fn Collider3D::set_one_way_below(Self, Float) -> Unit
pub fn Collider3D::set_parent(Self, @dynamics.RigidBodyHandle?) -> Unit
pub fn Collider3D::set_position(Self, @core.Isometry3) -> Unit
pub fn Collider3D::set_shape(Self, Shape3D) -> Unit
pub fn Collider3D::set_surface_velocity(Self, @core.Vec3) -> Unit
pub fn Collider3D::set_user_data(Self, Int) -> Self
pub fn Collider3D::set_user_data128(Self, @core.UserData128) -> Self
pub fn Collider3D::shape(Self) -> Shape3D
pub fn Collider3D::surface_velocity(Self) -> @core.Vec3
pub fn Collider3D::user_data(Self) -> Int
pub fn Collider3D::user_data128(Self) -> @core.UserData128
pub fn Collider3D::voxel_key_for_triangle(Self, Int) -> (Int, Int, Int)?

pub struct ColliderBuilder {
  shape : Shape
  mut translation : @core.Vec2
  mut rotation : Float
  mut active_collision_types : ActiveCollisionTypes
  mut sensor : Bool
  mut active_events : ActiveEvents
  mut active_hooks : ActiveHooks
  mut collision_groups : @dynamics.InteractionGroups
  mut solver_groups : @dynamics.InteractionGroups
  mut density : Float
  mut friction : Float
  mut friction_combine_rule : @dynamics.CoefficientCombineRule
  mut restitution : Float
  mut restitution_combine_rule : @dynamics.CoefficientCombineRule
  mut contact_skin : Float
  mut contact_force_event_threshold : Float
  mut user_data : @core.UserData128
  mut enabled : Bool
}
pub fn ColliderBuilder::active_collision_types(Self, ActiveCollisionTypes) -> Self
pub fn ColliderBuilder::active_events(Self, ActiveEvents) -> Self
pub fn ColliderBuilder::active_hooks(Self, ActiveHooks) -> Self
pub fn ColliderBuilder::ball(Float) -> Self
pub fn ColliderBuilder::build(Self) -> Collider
pub fn ColliderBuilder::capsule_from_endpoints(@core.Vec2, @core.Vec2, Float) -> Self
pub fn ColliderBuilder::capsule_x(Float, Float) -> Self
pub fn ColliderBuilder::capsule_y(Float, Float) -> Self
pub fn ColliderBuilder::collision_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder::compound(Array[(@core.Isometry2, Shape)]) -> Self
pub fn ColliderBuilder::contact_force_event_threshold(Self, Float) -> Self
pub fn ColliderBuilder::contact_skin(Self, Float) -> Self
pub fn ColliderBuilder::converted_trimesh(Array[@core.Vec2], Array[(Int, Int, Int)], MeshConverter) -> Result[Self, MeshConverterError]
pub fn ColliderBuilder::convex_decomposition_with_params(Array[@core.Vec2], Array[(Int, Int)], VHACDParameters) -> Self
pub fn ColliderBuilder::convex_hull(Array[@core.Vec2]) -> Self?
pub fn ColliderBuilder::convex_polyline(Array[@core.Vec2]) -> Self?
pub fn ColliderBuilder::cuboid(Float, Float) -> Self
pub fn ColliderBuilder::default_density() -> Float
pub fn ColliderBuilder::default_friction() -> Float
pub fn ColliderBuilder::delta(Self, @core.Isometry2) -> Self
pub fn ColliderBuilder::density(Self, Float) -> Self
pub fn ColliderBuilder::enabled(Self, Bool) -> Self
pub fn ColliderBuilder::friction(Self, Float) -> Self
pub fn ColliderBuilder::friction_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn ColliderBuilder::halfspace(@core.Vec2) -> Self
pub fn ColliderBuilder::heightfield(Array[Float], @core.Vec2) -> Self
pub fn ColliderBuilder::new(Shape) -> Self
pub fn ColliderBuilder::polyline(Array[@core.Vec2], Array[(Int, Int)]?) -> Self
pub fn ColliderBuilder::restitution(Self, Float) -> Self
pub fn ColliderBuilder::restitution_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn ColliderBuilder::rotation(Self, Float) -> Self
pub fn ColliderBuilder::round_convex_decomposition_with_params(Array[@core.Vec2], Array[(Int, Int)], VHACDParameters, Float) -> Self
pub fn ColliderBuilder::round_convex_hull(Array[@core.Vec2], Float) -> Self?
pub fn ColliderBuilder::round_convex_polyline(Array[@core.Vec2], Float) -> Self?
pub fn ColliderBuilder::round_cuboid(Float, Float, Float) -> Self
pub fn ColliderBuilder::round_triangle(@core.Vec2, @core.Vec2, @core.Vec2, Float) -> Self
pub fn ColliderBuilder::segment(@core.Vec2, @core.Vec2) -> Self
pub fn ColliderBuilder::sensor(Self, Bool) -> Self
pub fn ColliderBuilder::solver_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder::translation(Self, @core.Vec2) -> Self
pub fn ColliderBuilder::triangle(@core.Vec2, @core.Vec2, @core.Vec2) -> Self
pub fn ColliderBuilder::trimesh(Array[@core.Vec2], Array[(Int, Int, Int)]) -> Self?
pub fn ColliderBuilder::trimesh_with_flags(Array[@core.Vec2], Array[(Int, Int, Int)], TriMeshFlags) -> Self?
pub fn ColliderBuilder::user_data(Self, Int) -> Self
pub fn ColliderBuilder::user_data128(Self, @core.UserData128) -> Self
pub fn ColliderBuilder::voxelized_mesh(Array[@core.Vec2], Array[(Int, Int)], Float, FillMode) -> Self
pub fn ColliderBuilder::voxels(@core.Vec2, Array[(Int, Int)]) -> Self
pub fn ColliderBuilder::voxels_from_points(@core.Vec2, Array[@core.Vec2]) -> Self

pub struct ColliderBuilder3 {
  inner : ColliderBuilder
}
pub fn ColliderBuilder3::active_collision_types(Self, ActiveCollisionTypes) -> Self
pub fn ColliderBuilder3::active_events(Self, ActiveEvents) -> Self
pub fn ColliderBuilder3::active_hooks(Self, ActiveHooks) -> Self
pub fn ColliderBuilder3::ball(Float) -> Self
pub fn ColliderBuilder3::build(Self) -> Collider
pub fn ColliderBuilder3::capsule_x(Float, Float) -> Self
pub fn ColliderBuilder3::capsule_y(Float, Float) -> Self
pub fn ColliderBuilder3::collision_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder3::compound(Array[(@core.Isometry3, SharedShape)]) -> Self
pub fn ColliderBuilder3::cone(Float, Float) -> Self
pub fn ColliderBuilder3::contact_skin(Self, Float) -> Self
pub fn ColliderBuilder3::convex_hull(Array[@core.Vec3]) -> Self?
pub fn ColliderBuilder3::cuboid(Float, Float, Float) -> Self
pub fn ColliderBuilder3::density(Self, Float) -> Self
pub fn ColliderBuilder3::friction(Self, Float) -> Self
pub fn ColliderBuilder3::heightfield(Array[Float], @core.Vec3) -> Self
pub fn ColliderBuilder3::restitution(Self, Float) -> Self
pub fn ColliderBuilder3::rotation(Self, @core.Quat) -> Self
pub fn ColliderBuilder3::rotation_scaled_axis(Self, @core.Vec3) -> Self
pub fn ColliderBuilder3::round_convex_hull(Array[@core.Vec3], Float) -> Self?
pub fn ColliderBuilder3::round_cylinder(Float, Float, Float) -> Self
pub fn ColliderBuilder3::segment(@core.Vec3, @core.Vec3) -> Self
pub fn ColliderBuilder3::sensor(Self, Bool) -> Self
pub fn ColliderBuilder3::solver_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder3::translation(Self, @core.Vec3) -> Self
pub fn ColliderBuilder3::trimesh(Array[@core.Vec3], Array[(Int, Int, Int)]) -> Self?
pub fn ColliderBuilder3::voxelized_mesh(Array[@core.Vec3], Array[(Int, Int)], Float, FillMode) -> Self
pub fn ColliderBuilder3::voxels_from_points(@core.Vec3, Array[@core.Vec3]) -> Self

pub struct ColliderBuilder3D {
  mut position : @core.Isometry3
  mut local_position : @core.Isometry3
  parent : @dynamics.RigidBodyHandle?
  shape : Shape3D
  voxel_tri_map : Array[(Int, Int, Int)]?
  mut enabled : Bool
  mut sensor : Bool
  mut surface_velocity : @core.Vec3
  mut one_way_offset : Float?
  mut one_way_direction : Int
  mut active_events : ActiveEvents
  mut contact_force_event_threshold : Float
  mut user_data : @core.UserData128
  mut collision_groups : @dynamics.InteractionGroups
  mut friction : Float
  mut restitution : Float
}
pub fn ColliderBuilder3D::active_events(Self, ActiveEvents) -> Self
pub fn ColliderBuilder3D::ball(Float) -> Self
pub fn ColliderBuilder3D::build(Self) -> Collider3D
pub fn ColliderBuilder3D::capsule_x(Float, Float) -> Self
pub fn ColliderBuilder3D::capsule_y(Float, Float) -> Self
pub fn ColliderBuilder3D::capsule_z(Float, Float) -> Self
pub fn ColliderBuilder3D::collision_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder3D::compound(Array[(@core.Isometry3, Self)]) -> Self?
pub fn ColliderBuilder3D::cone(Float, Float) -> Self
pub fn ColliderBuilder3D::contact_force_event_threshold(Self, Float) -> Self
pub fn ColliderBuilder3D::convex_decomposition(Array[@core.Vec3], Array[(Int, Int, Int)]) -> Self?
pub fn ColliderBuilder3D::convex_hull(Array[@core.Vec3]) -> Self?
pub fn ColliderBuilder3D::convex_mesh(Array[@core.Vec3], Array[(Int, Int, Int)]) -> Self?
pub fn ColliderBuilder3D::cuboid(Float, Float, Float) -> Self
pub fn ColliderBuilder3D::cylinder(Float, Float) -> Self
pub fn ColliderBuilder3D::density(Self, Float) -> Self
pub fn ColliderBuilder3D::enabled(Self, Bool) -> Self
pub fn ColliderBuilder3D::friction(Self, Float) -> Self
pub fn ColliderBuilder3D::halfspace(@core.Vec3) -> Self
pub fn ColliderBuilder3D::heightfield(Array[Float], Int, Int, @core.Vec3) -> Self?
pub fn ColliderBuilder3D::heightfield_with_flags(Array[Float], Int, Int, @core.Vec3, Int) -> Self?
pub fn ColliderBuilder3D::local_position(Self, @core.Isometry3) -> Self
pub fn ColliderBuilder3D::one_way_above(Self, Float) -> Self
pub fn ColliderBuilder3D::one_way_below(Self, Float) -> Self
pub fn ColliderBuilder3D::position(Self, @core.Isometry3) -> Self
pub fn ColliderBuilder3D::restitution(Self, Float) -> Self
pub fn ColliderBuilder3D::rotation(Self, @core.Quat) -> Self
pub fn ColliderBuilder3D::round_cone(Float, Float, Float) -> Self
pub fn ColliderBuilder3D::round_convex_decomposition(Array[@core.Vec3], Array[(Int, Int, Int)], Float) -> Self?
pub fn ColliderBuilder3D::round_convex_hull(Array[@core.Vec3], Float) -> Self?
pub fn ColliderBuilder3D::round_convex_mesh(Array[@core.Vec3], Array[(Int, Int, Int)], Float) -> Self?
pub fn ColliderBuilder3D::round_cylinder(Float, Float, Float) -> Self
pub fn ColliderBuilder3D::sensor(Self, Bool) -> Self
pub fn ColliderBuilder3D::surface_velocity(Self, @core.Vec3) -> Self
pub fn ColliderBuilder3D::translation(Self, @core.Vec3) -> Self
pub fn ColliderBuilder3D::triangle(@core.Vec3, @core.Vec3, @core.Vec3) -> Self
pub fn ColliderBuilder3D::trimesh(Array[@core.Vec3], Array[(Int, Int, Int)]) -> Self?
pub fn ColliderBuilder3D::user_data(Self, Int) -> Self
pub fn ColliderBuilder3D::user_data128(Self, @core.UserData128) -> Self
pub fn ColliderBuilder3D::voxels_from_points(@core.Vec3, Array[@core.Vec3]) -> Self?

pub struct ColliderChanges {
  bits : Int
}
pub fn ColliderChanges::all() -> Self
pub fn ColliderChanges::contains(Self, Int) -> Bool
pub fn ColliderChanges::empty() -> Self
pub fn ColliderChanges::insert(Self, Int) -> Self
pub fn ColliderChanges::needs_broad_phase_update(Self) -> Bool
pub fn ColliderChanges::needs_narrow_phase_update(Self) -> Bool
pub fn ColliderChanges::remove(Self, Int) -> Self

pub(all) enum ColliderEnabled {
  Enabled
  DisabledByParent
  Disabled
}

pub struct ColliderFlags {
  collision_groups : @dynamics.InteractionGroups
  solver_groups : @dynamics.InteractionGroups
  active_collision_types : ActiveCollisionTypes
  active_hooks : ActiveHooks
  active_events : ActiveEvents
}
pub fn ColliderFlags::new(@dynamics.InteractionGroups, @dynamics.InteractionGroups, ActiveCollisionTypes, ActiveHooks, ActiveEvents) -> Self

pub struct ColliderHandle {
  id : Int
  generation : Int
}
pub fn ColliderHandle::equals(Self, Self) -> Bool
pub fn ColliderHandle::from_raw_parts(Int, Int) -> Self
pub fn ColliderHandle::into_raw_parts(Self) -> (Int, Int)
pub fn ColliderHandle::invalid() -> Self

pub struct ColliderHandle3D {
  id : Int
  generation : Int
}
pub fn ColliderHandle3D::equals(Self, Self) -> Bool
pub fn ColliderHandle3D::from_raw_parts(Int, Int) -> Self
pub fn ColliderHandle3D::into_raw_parts(Self) -> (Int, Int)
pub fn ColliderHandle3D::invalid() -> Self

pub(all) enum ColliderMassProps {
  Density(Float)
  Mass(Float)
  MassProperties(@core.MassProperties)
}
pub fn ColliderMassProps::default() -> Self

pub struct ColliderMaterial {
  friction : Float
  restitution : Float
  friction_combine_rule : @dynamics.CoefficientCombineRule
  restitution_combine_rule : @dynamics.CoefficientCombineRule
}

pub struct ColliderPair {
  collider1 : ColliderHandle
  collider2 : ColliderHandle
}
pub fn ColliderPair::collider1(Self) -> ColliderHandle
pub fn ColliderPair::collider2(Self) -> ColliderHandle
pub fn ColliderPair::new(ColliderHandle, ColliderHandle) -> Self
pub fn ColliderPair::swap(Self) -> Self

pub struct ColliderPair3D {
  collider1 : ColliderHandle3D
  collider2 : ColliderHandle3D
}
pub fn ColliderPair3D::collider1(Self) -> ColliderHandle3D
pub fn ColliderPair3D::collider2(Self) -> ColliderHandle3D
pub fn ColliderPair3D::new(ColliderHandle3D, ColliderHandle3D) -> Self

pub struct ColliderParent {
  handle : @dynamics.RigidBodyHandle
  pos_wrt_parent : @core.Isometry2
}
pub fn ColliderParent::new(@dynamics.RigidBodyHandle, @core.Isometry2) -> Self

pub struct ColliderPosition {
  position : @core.Isometry2
}
pub fn ColliderPosition::new(@core.Isometry2) -> Self

pub struct ColliderSet {
  colliders : Array[Collider?]
  generations : Array[Int]
  free_list : Array[Int]
  modified_colliders : Array[ColliderHandle]
  mut removed_colliders : Array[ColliderHandle]
}
pub fn ColliderSet::clear_changes_for(Self, Array[ColliderHandle]) -> Unit
pub fn ColliderSet::colliders_with_parent(Self, @dynamics.RigidBodyHandle) -> Array[ColliderHandle]
pub fn ColliderSet::deserialize(String) -> Self
pub fn ColliderSet::get(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::get_mut(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::get_mut_internal(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::get_mut_internal_with_modification_tracking(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::insert(Self, Collider) -> ColliderHandle
pub fn ColliderSet::insert_with_parent(Self, Collider, @dynamics.RigidBodyHandle, @dynamics.RigidBodySet) -> ColliderHandle
pub fn ColliderSet::invalid_handle() -> ColliderHandle
pub fn ColliderSet::is_empty(Self) -> Bool
pub fn ColliderSet::iter_enabled(Self) -> Array[(ColliderHandle, Collider)]
pub fn ColliderSet::iter_enabled_mut(Self) -> Array[(ColliderHandle, Collider)]
pub fn ColliderSet::len(Self) -> Int
pub fn ColliderSet::new() -> Self
pub fn ColliderSet::remove(Self, ColliderHandle, @dynamics.IslandManager, @dynamics.RigidBodySet, Bool) -> Unit
pub fn ColliderSet::serialize(Self) -> String
pub fn ColliderSet::set_parent(Self, ColliderHandle, @dynamics.RigidBodyHandle?, @dynamics.RigidBodySet) -> Unit
pub fn ColliderSet::set_parent_enabled(Self, @dynamics.RigidBodyHandle, Bool) -> Unit
pub fn ColliderSet::take_modified(Self) -> Array[ColliderHandle]
pub fn ColliderSet::take_removed(Self) -> Array[ColliderHandle]

pub struct ColliderSet3 {
  inner : ColliderSet
}
pub fn ColliderSet3::as_2d(Self) -> ColliderSet
pub fn ColliderSet3::get(Self, ColliderHandle) -> Collider?
pub fn ColliderSet3::insert(Self, Collider) -> ColliderHandle
pub fn ColliderSet3::insert_with_parent(Self, Collider, @dynamics.RigidBodyHandle, @dynamics.RigidBodySet3) -> ColliderHandle
pub fn ColliderSet3::len(Self) -> Int
pub fn ColliderSet3::new() -> Self
pub fn ColliderSet3::remove(Self, ColliderHandle, @dynamics.IslandManager3, @dynamics.RigidBodySet3, Bool) -> Unit
pub fn ColliderSet3::set_parent(Self, ColliderHandle, @dynamics.RigidBodyHandle?, @dynamics.RigidBodySet3) -> Unit

pub struct ColliderSet3D {
  colliders : Array[Collider3D?]
  generations : Array[Int]
  free_list : Array[Int]
}
pub fn ColliderSet3D::all_handles(Self) -> Array[ColliderHandle3D]
pub fn ColliderSet3D::get(Self, ColliderHandle3D) -> Collider3D?
pub fn ColliderSet3D::get_mut(Self, ColliderHandle3D) -> Collider3D?
pub fn ColliderSet3D::insert(Self, Collider3D) -> ColliderHandle3D
pub fn ColliderSet3D::insert_with_parent(Self, Collider3D, @dynamics.RigidBodyHandle, @dynamics.RigidBodySet3D) -> ColliderHandle3D
pub fn ColliderSet3D::len(Self) -> Int
pub fn ColliderSet3D::new() -> Self
pub fn ColliderSet3D::remove(Self, ColliderHandle3D) -> Collider3D?
pub fn ColliderSet3D::remove_attached_to(Self, @dynamics.RigidBodyHandle) -> Array[ColliderHandle3D]
pub fn ColliderSet3D::set_parent(Self, ColliderHandle3D, @dynamics.RigidBodyHandle?, @dynamics.RigidBodySet3D) -> Unit
pub fn ColliderSet3D::sync_with_bodies(Self, @dynamics.RigidBodySet3D) -> Unit

pub(all) enum ColliderType {
  Solid
  Sensor
}
pub fn ColliderType::is_sensor(Self) -> Bool

pub(all) enum CollisionEvent {
  Started(ColliderHandle, ColliderHandle, CollisionEventFlags)
  Stopped(ColliderHandle, ColliderHandle, CollisionEventFlags)
}
pub fn CollisionEvent::collider1(Self) -> ColliderHandle
pub fn CollisionEvent::collider2(Self) -> ColliderHandle
pub fn CollisionEvent::removed(Self) -> Bool
pub fn CollisionEvent::sensor(Self) -> Bool
pub fn CollisionEvent::started(Self) -> Bool
pub fn CollisionEvent::stopped(Self) -> Bool

pub(all) enum CollisionEvent3D {
  Started(ColliderHandle3D, ColliderHandle3D, CollisionEventFlags)
  Stopped(ColliderHandle3D, ColliderHandle3D, CollisionEventFlags)
}
pub fn CollisionEvent3D::collider1(Self) -> ColliderHandle3D
pub fn CollisionEvent3D::collider2(Self) -> ColliderHandle3D
pub fn CollisionEvent3D::removed(Self) -> Bool
pub fn CollisionEvent3D::sensor(Self) -> Bool
pub fn CollisionEvent3D::started(Self) -> Bool
pub fn CollisionEvent3D::stopped(Self) -> Bool

pub struct CollisionEventFlags {
  mut bits : Int
}
pub fn CollisionEventFlags::contains(Self, Self) -> Bool
pub fn CollisionEventFlags::empty() -> Self
pub fn CollisionEventFlags::insert(Self, Self) -> Self
pub fn CollisionEventFlags::removed() -> Self
pub fn CollisionEventFlags::sensor() -> Self

pub(all) struct ContactData {
  impulse : Float
  tangent_impulse : @core.Vec2
  warmstart_impulse : Float
  warmstart_tangent_impulse : @core.Vec2
  warmstart_twist_impulse : Float
}
pub fn ContactData::default() -> Self
pub fn ContactData::new(Float, @core.Vec2, Float, @core.Vec2, Float) -> Self

pub struct ContactForceEvent {
  collider1 : ColliderHandle
  collider2 : ColliderHandle
  total_force : @core.Vec2
  total_force_magnitude : Float
  max_force_direction : @core.Vec2
  max_force_magnitude : Float
}
pub fn ContactForceEvent::collider1(Self) -> ColliderHandle
pub fn ContactForceEvent::collider2(Self) -> ColliderHandle
pub fn ContactForceEvent::from_contact_pair(Float, ColliderHandle, ColliderHandle, ContactPair, Float) -> Self
pub fn ContactForceEvent::max_force_direction(Self) -> @core.Vec2
pub fn ContactForceEvent::max_force_magnitude(Self) -> Float
pub fn ContactForceEvent::new(ColliderHandle, ColliderHandle, @core.Vec2, Float, @core.Vec2, Float) -> Self
pub fn ContactForceEvent::total_force(Self) -> @core.Vec2
pub fn ContactForceEvent::total_force_magnitude(Self) -> Float

pub struct ContactForceEvent3D {
  collider1 : ColliderHandle3D
  collider2 : ColliderHandle3D
  total_force : @core.Vec3
  total_force_magnitude : Float
  max_force_direction : @core.Vec3
  max_force_magnitude : Float
}
pub fn ContactForceEvent3D::collider1(Self) -> ColliderHandle3D
pub fn ContactForceEvent3D::collider2(Self) -> ColliderHandle3D
pub fn ContactForceEvent3D::from_contact_pair(Float, ColliderHandle3D, ColliderHandle3D, ContactPair3D, Float) -> Self
pub fn ContactForceEvent3D::max_force_direction(Self) -> @core.Vec3
pub fn ContactForceEvent3D::max_force_magnitude(Self) -> Float
pub fn ContactForceEvent3D::new(ColliderHandle3D, ColliderHandle3D, @core.Vec3, Float, @core.Vec3, Float) -> Self
pub fn ContactForceEvent3D::total_force(Self) -> @core.Vec3
pub fn ContactForceEvent3D::total_force_magnitude(Self) -> Float

pub struct ContactManifold {
  normal : @core.Vec2
  points : Array[ContactManifoldPoint]
}
pub fn ContactManifold::new(@core.Vec2, Array[ContactManifoldPoint]) -> Self
pub fn ContactManifold::normal(Self) -> @core.Vec2
pub fn ContactManifold::points(Self) -> Array[ContactManifoldPoint]

pub struct ContactManifoldData {
  solver_flags : SolverFlags
  solver_contacts : Array[SolverContactGeneric]
  relative_dominance : Int
}
pub fn ContactManifoldData::default() -> Self
pub fn ContactManifoldData::num_active_contacts(Self) -> Int

#alias(Contact)
pub struct ContactManifoldPoint {
  local_p1 : @core.Vec2
  local_p2 : @core.Vec2
  dist : Float
  fid1 : FeatureId
  fid2 : FeatureId
  mut data : ContactData
}
pub fn ContactManifoldPoint::data(Self) -> ContactData
pub fn ContactManifoldPoint::dist(Self) -> Float
pub fn ContactManifoldPoint::fid1(Self) -> FeatureId
pub fn ContactManifoldPoint::fid2(Self) -> FeatureId
pub fn ContactManifoldPoint::local_p1(Self) -> @core.Vec2
pub fn ContactManifoldPoint::local_p2(Self) -> @core.Vec2
pub fn ContactManifoldPoint::set_data(Self, ContactData) -> Unit

pub struct ContactPair {
  manifolds : Array[ContactManifold]
}
pub fn ContactPair::find_deepest_contact(Self) -> (ContactManifold, ContactManifoldPoint)?
pub fn ContactPair::has_any_active_contact(Self) -> Bool
pub fn ContactPair::manifold_count(Self) -> Int
pub fn ContactPair::manifolds(Self) -> Array[ContactManifold]
pub fn ContactPair::max_impulse(Self) -> (Float, @core.Vec2)
pub fn ContactPair::total_impulse(Self) -> @core.Vec2
pub fn ContactPair::total_impulse_magnitude(Self) -> Float

pub struct ContactPair3D {
  manifolds : Array[ContactPoint3D]
  impulses : Array[Float]
}
pub fn ContactPair3D::manifolds(Self) -> Array[ContactPoint3D]
pub fn ContactPair3D::manifolds_len(Self) -> Int
pub fn ContactPair3D::max_impulse(Self) -> (Float, @core.Vec3)
pub fn ContactPair3D::set_normal_impulse_at(Self, Int, Float) -> Unit
pub fn ContactPair3D::total_impulse(Self) -> @core.Vec3
pub fn ContactPair3D::total_impulse_magnitude(Self) -> Float

pub struct ContactPoint3D {
  point1 : @core.Vec3
  point2 : @core.Vec3
  normal : @core.Vec3
  penetration : Float
}

pub(all) enum FeatureId {
  Unknown
  Vertex(Int)
  Edge(Int)
  Face(Int)
}

pub(all) enum FillMode {
  SurfaceOnly
  FloodFill(Bool, Bool)
}
pub fn FillMode::default() -> Self
pub fn FillMode::surface_only() -> Self

pub struct HeightField {
  heights : Array[Float]
  scale : @core.Vec2
}
pub fn HeightField::as_shape(Self) -> Shape
pub fn HeightField::new(Array[Float], @core.Vec2) -> Self

pub struct InteractionGraph[T] {
  interactions : Array[(ColliderHandle, ColliderHandle, T)]
}
pub fn[T] InteractionGraph::index_interaction(Self[T], ColliderHandle, ColliderHandle) -> Int?
pub fn[T] InteractionGraph::interaction_pair(Self[T], ColliderHandle, ColliderHandle) -> T?
pub fn[T] InteractionGraph::interaction_pair_mut(Self[T], ColliderHandle, ColliderHandle) -> T?
pub fn[T] InteractionGraph::interactions(Self[T]) -> Array[(ColliderHandle, ColliderHandle, T)]
pub fn[T] InteractionGraph::interactions_with(Self[T], ColliderHandle) -> Array[(ColliderHandle, ColliderHandle, T)]
pub fn[T] InteractionGraph::interactions_with_endpoints(Self[T], ColliderHandle, ColliderHandle) -> Array[(ColliderHandle, ColliderHandle, T)]
pub fn[T] InteractionGraph::interactions_with_mut(Self[T], ColliderHandle) -> Array[(ColliderHandle, ColliderHandle, T)]
pub fn[T] InteractionGraph::new() -> Self[T]
pub fn[T] InteractionGraph::raw_graph(Self[T]) -> Array[(ColliderHandle, ColliderHandle, T)]

pub struct IntersectionEvent {
  collider1 : ColliderHandle
  collider2 : ColliderHandle
  intersecting : Bool
}
pub fn IntersectionEvent::collider1(Self) -> ColliderHandle
pub fn IntersectionEvent::collider2(Self) -> ColliderHandle
pub fn IntersectionEvent::intersecting(Self) -> Bool
pub fn IntersectionEvent::new(ColliderHandle, ColliderHandle, Bool) -> Self

pub struct IntersectionEvent3D {
  collider1 : ColliderHandle3D
  collider2 : ColliderHandle3D
  intersecting : Bool
}
pub fn IntersectionEvent3D::collider1(Self) -> ColliderHandle3D
pub fn IntersectionEvent3D::collider2(Self) -> ColliderHandle3D
pub fn IntersectionEvent3D::intersecting(Self) -> Bool
pub fn IntersectionEvent3D::new(ColliderHandle3D, ColliderHandle3D, Bool) -> Self

pub struct IntersectionPair {
  collider1 : ColliderHandle
  collider2 : ColliderHandle
  intersecting : Bool
}

pub struct IntersectionPair3D {
  collider1 : ColliderHandle3D
  collider2 : ColliderHandle3D
  intersecting : Bool
}
pub fn IntersectionPair3D::collider1(Self) -> ColliderHandle3D
pub fn IntersectionPair3D::collider2(Self) -> ColliderHandle3D
pub fn IntersectionPair3D::intersecting(Self) -> Bool

pub(all) enum MeshConverter {
  TriMesh
  TriMeshWithFlags(TriMeshFlags)
  Aabb
  Obb
  ConvexHull
  ConvexDecomposition
  ConvexDecompositionWithParams(VHACDParameters)
}
pub fn MeshConverter::aabb() -> Self
pub fn MeshConverter::apply(Self, Array[@core.Vec2], Array[(Int, Int, Int)]) -> Result[(SharedShape, @core.Isometry2), MeshConverterError]
pub fn MeshConverter::convert(Self, Array[@core.Vec2], Array[(Int, Int, Int)]) -> Result[(SharedShape, @core.Isometry2), MeshConverterError]
pub fn MeshConverter::convex_hull() -> Self
pub fn MeshConverter::obb() -> Self
pub fn MeshConverter::trimesh() -> Self
pub fn MeshConverter::trimesh_with_flags(TriMeshFlags) -> Self

pub(all) enum MeshConverterError {
  ConvexHullFailed
  TriMeshBuilderError
  EmptyVertices
}
pub fn MeshConverterError::to_string(Self) -> String

pub struct NarrowPhase {
  mut intersections : Array[IntersectionPair]
  mut contacts : Array[(ColliderHandle, ColliderHandle, ContactPair)]
}
pub fn NarrowPhase::contact_graph(Self) -> InteractionGraph[ContactPair]
pub fn NarrowPhase::contact_pair(Self, ColliderHandle, ColliderHandle) -> ContactPair?
pub fn NarrowPhase::contact_pair_at_index(Self, Int) -> (ColliderHandle, ColliderHandle, ContactPair)?
pub fn NarrowPhase::contact_pair_unknown_gen(Self, ColliderHandle, ColliderHandle) -> ContactPair?
pub fn NarrowPhase::contact_pairs(Self) -> Array[(ColliderHandle, ColliderHandle, ContactPair)]
pub fn NarrowPhase::contact_pairs_with(Self, ColliderHandle) -> Array[(ColliderHandle, ColliderHandle, ContactPair)]
pub fn NarrowPhase::contact_pairs_with_unknown_gen(Self, ColliderHandle) -> Array[(ColliderHandle, ColliderHandle, ContactPair)]
pub fn NarrowPhase::handle_user_changes(Self, @dynamics.RigidBodySet, ColliderSet, Array[ColliderHandle]) -> Unit
pub fn NarrowPhase::intersection_graph(Self) -> InteractionGraph[IntersectionPair]
pub fn NarrowPhase::intersection_pair(Self, ColliderHandle, ColliderHandle) -> IntersectionPair?
pub fn NarrowPhase::intersection_pair_unknown_gen(Self, ColliderHandle, ColliderHandle) -> IntersectionPair?
pub fn NarrowPhase::intersection_pairs(Self) -> Array[IntersectionPair]
pub fn NarrowPhase::intersection_pairs_with(Self, ColliderHandle) -> Array[IntersectionPair]
pub fn NarrowPhase::intersection_pairs_with_unknown_gen(Self, ColliderHandle) -> Array[IntersectionPair]
pub fn NarrowPhase::new() -> Self
pub fn NarrowPhase::query_dispatcher(Self) -> Unit
pub fn NarrowPhase::update(Self, @dynamics.RigidBodySet, ColliderSet, @dynamics.ImpulseJointSet, @dynamics.MultibodyJointSet) -> Unit
pub fn NarrowPhase::update_with_pairs(Self, @dynamics.RigidBodySet, ColliderSet, Float, Array[(ColliderHandle, ColliderHandle)], @dynamics.ImpulseJointSet, @dynamics.MultibodyJointSet) -> Unit
pub fn NarrowPhase::with_query_dispatcher(Self, Unit) -> Self

pub struct NarrowPhase3D {
  contact_pairs : Array[((ColliderHandle3D, ColliderHandle3D), ContactPair3D)]
  intersection_pairs : Array[((ColliderHandle3D, ColliderHandle3D), IntersectionPair3D)]
}
pub fn NarrowPhase3D::all_contact_pairs(Self) -> Array[((ColliderHandle3D, ColliderHandle3D), ContactPair3D)]
pub fn NarrowPhase3D::all_intersection_pairs(Self) -> Array[((ColliderHandle3D, ColliderHandle3D), IntersectionPair3D)]
pub fn NarrowPhase3D::clear(Self) -> Unit
pub fn NarrowPhase3D::contact_pair(Self, ColliderHandle3D, ColliderHandle3D) -> ContactPair3D?
pub fn NarrowPhase3D::intersection_pair(Self, ColliderHandle3D, ColliderHandle3D) -> IntersectionPair3D?
pub fn NarrowPhase3D::new() -> Self
pub fn NarrowPhase3D::set_contact_pair_normal_impulses(Self, ColliderHandle3D, ColliderHandle3D, Array[Float]) -> Unit
pub fn NarrowPhase3D::update(Self, Array[(ColliderHandle3D, ColliderHandle3D)], @dynamics.RigidBodySet3D, ColliderSet3D) -> Unit

pub struct NonlinearRigidMotion {
  start_pos : @core.Isometry2
  linvel : @core.Vec2
  angvel : Float
}
pub fn NonlinearRigidMotion::identity() -> Self
pub fn NonlinearRigidMotion::new(@core.Isometry2, @core.Vec2, Float) -> Self

pub struct PointProjection {
  point : @core.Vec2
  is_inside : Bool
}
pub fn PointProjection::is_inside(Self) -> Bool
pub fn PointProjection::point(Self) -> @core.Vec2

pub struct PointProjection3 {
  point : @core.Vec3
  is_inside : Bool
}
pub fn PointProjection3::is_inside(Self) -> Bool
pub fn PointProjection3::point(Self) -> @core.Vec3

pub struct QueryFilter {
  excluded_body : @dynamics.RigidBodyHandle?
  excluded_collider : ColliderHandle?
  mut groups : @dynamics.InteractionGroups?
  mut flags : QueryFilterFlags
  mut predicate : ((ColliderHandle, Collider) -> Bool)?
}
pub fn QueryFilter::exclude_collider(Self, ColliderHandle) -> Self
pub fn QueryFilter::exclude_dynamic(Self) -> Self
pub fn QueryFilter::exclude_fixed(Self) -> Self
pub fn QueryFilter::exclude_kinematic(Self) -> Self
pub fn QueryFilter::exclude_rigid_body(Self, @dynamics.RigidBodyHandle) -> Self
pub fn QueryFilter::exclude_sensors(Self) -> Self
pub fn QueryFilter::exclude_solids(Self) -> Self
pub fn QueryFilter::groups(Self, @dynamics.InteractionGroups) -> Self
pub fn QueryFilter::groups_filter(Self) -> @dynamics.InteractionGroups?
pub fn QueryFilter::new() -> Self
pub fn QueryFilter::only_dynamic() -> Self
pub fn QueryFilter::only_fixed() -> Self
pub fn QueryFilter::only_kinematic() -> Self
pub fn QueryFilter::passes(Self, @dynamics.RigidBodySet, ColliderHandle, Collider) -> Bool
pub fn QueryFilter::predicate(Self, (ColliderHandle, Collider) -> Bool) -> Self

pub struct QueryFilter3DReal {
  excluded_body : @dynamics.RigidBodyHandle?
  excluded_collider : ColliderHandle3D?
  mut groups : @dynamics.InteractionGroups?
  mut flags : QueryFilterFlags
  mut predicate : ((ColliderHandle3D, Collider3D) -> Bool)?
}
pub fn QueryFilter3DReal::exclude_collider(Self, ColliderHandle3D) -> Self
pub fn QueryFilter3DReal::exclude_dynamic(Self) -> Self
pub fn QueryFilter3DReal::exclude_fixed(Self) -> Self
pub fn QueryFilter3DReal::exclude_kinematic(Self) -> Self
pub fn QueryFilter3DReal::exclude_rigid_body(Self, @dynamics.RigidBodyHandle) -> Self
pub fn QueryFilter3DReal::exclude_sensors(Self) -> Self
pub fn QueryFilter3DReal::exclude_solids(Self) -> Self
pub fn QueryFilter3DReal::groups(Self, @dynamics.InteractionGroups) -> Self
pub fn QueryFilter3DReal::new() -> Self
pub fn QueryFilter3DReal::only_dynamic() -> Self
pub fn QueryFilter3DReal::only_fixed() -> Self
pub fn QueryFilter3DReal::only_kinematic() -> Self
pub fn QueryFilter3DReal::predicate(Self, (ColliderHandle3D, Collider3D) -> Bool) -> Self

pub struct QueryFilterFlags {
  mut bits : Int
}
pub fn QueryFilterFlags::complement(Self) -> Self
pub fn QueryFilterFlags::contains(Self, Int) -> Bool
pub fn QueryFilterFlags::difference(Self, Self) -> Self
pub fn QueryFilterFlags::empty() -> Self
pub fn QueryFilterFlags::exclude_dynamic() -> Self
pub fn QueryFilterFlags::exclude_fixed() -> Self
pub fn QueryFilterFlags::exclude_kinematic() -> Self
pub fn QueryFilterFlags::exclude_sensors() -> Self
pub fn QueryFilterFlags::exclude_solids() -> Self
pub fn QueryFilterFlags::from_bits(Int) -> Self?
pub fn QueryFilterFlags::from_bits_retain(Int) -> Self
pub fn QueryFilterFlags::from_bits_truncate(Int) -> Self
pub fn QueryFilterFlags::from_name(String) -> Self?
pub fn QueryFilterFlags::insert(Self, Int) -> Self
pub fn QueryFilterFlags::is_all(Self) -> Bool
pub fn QueryFilterFlags::iter_names(Self) -> Array[String]
pub fn QueryFilterFlags::new(Int) -> Self
pub fn QueryFilterFlags::only_dynamic() -> Self
pub fn QueryFilterFlags::only_fixed() -> Self
pub fn QueryFilterFlags::only_kinematic() -> Self
pub fn QueryFilterFlags::passes(Self, @dynamics.RigidBodySet, Collider) -> Bool
pub fn QueryFilterFlags::symmetric_difference(Self, Self) -> Self
pub fn QueryFilterFlags::toggle(Self, Self) -> Self
pub fn QueryFilterFlags::union(Self, Self) -> Self

pub struct QueryPipeline {
  bvh : Bvh
  filter : QueryFilter
}
pub fn QueryPipeline::cast_ray(Self, @dynamics.RigidBodySet, ColliderSet, Ray, Float, Bool) -> (ColliderHandle, Float)?
pub fn QueryPipeline::cast_ray_and_get_normal(Self, @dynamics.RigidBodySet, ColliderSet, Ray, Float, Bool) -> (ColliderHandle, RayIntersection)?
pub fn QueryPipeline::cast_shape(Self, @dynamics.RigidBodySet, ColliderSet, @core.Isometry2, @core.Vec2, Shape, ShapeCastOptions) -> (ColliderHandle, ShapeCastHit)?
pub fn QueryPipeline::cast_shape_nonlinear(Self, @dynamics.RigidBodySet, ColliderSet, NonlinearRigidMotion, Shape, Float, Float, Bool) -> (ColliderHandle, ShapeCastHit)?
pub fn QueryPipeline::collider(Self, ColliderSet, ColliderHandle) -> Collider?
pub fn QueryPipeline::intersect_aabb_conservative(Self, @dynamics.RigidBodySet, ColliderSet, @core.Aabb) -> Array[ColliderHandle]
pub fn QueryPipeline::intersect_point(Self, @dynamics.RigidBodySet, ColliderSet, @core.Vec2) -> Array[ColliderHandle]
pub fn QueryPipeline::intersect_ray(Self, @dynamics.RigidBodySet, ColliderSet, Ray, Float, Bool) -> Array[(ColliderHandle, RayIntersection)]
pub fn QueryPipeline::intersect_shape(Self, @dynamics.RigidBodySet, ColliderSet, @core.Isometry2, Shape) -> Array[ColliderHandle]
pub fn QueryPipeline::new(QueryFilter, @dynamics.RigidBodySet, ColliderSet) -> Self
pub fn QueryPipeline::new3(QueryFilter, @dynamics.RigidBodySet3, ColliderSet3) -> Self
pub fn QueryPipeline::project_point(Self, @dynamics.RigidBodySet, ColliderSet, @core.Vec2, Float, Bool) -> (ColliderHandle, PointProjection)?
pub fn QueryPipeline::project_point_and_get_feature(Self, @dynamics.RigidBodySet, ColliderSet, @core.Vec2, Float, Bool) -> (ColliderHandle, PointProjection, FeatureId)?
pub fn QueryPipeline::rigid_body(Self, @dynamics.RigidBodySet, @dynamics.RigidBodyHandle) -> @dynamics.RigidBody?
pub fn QueryPipeline::update(Self, @dynamics.RigidBodySet, ColliderSet) -> Unit
pub fn QueryPipeline::with_filter(Self, QueryFilter) -> Self

pub struct QueryPipeline3DReal {
  filter : QueryFilter3DReal
  mut cached_aabbs : Array[@core.Aabb3?]
}
pub fn QueryPipeline3DReal::cast_ray(Self, @dynamics.RigidBodySet3D, ColliderSet3D, Ray3, Float, Bool) -> (ColliderHandle3D, Float)?
pub fn QueryPipeline3DReal::cast_ray_and_get_normal(Self, @dynamics.RigidBodySet3D, ColliderSet3D, Ray3, Float, Bool) -> (ColliderHandle3D, RayIntersection3)?
pub fn QueryPipeline3DReal::cast_ray_and_get_normal_and_feature(Self, @dynamics.RigidBodySet3D, ColliderSet3D, Ray3, Float, Bool) -> (ColliderHandle3D, RayIntersection3Feature)?
pub fn QueryPipeline3DReal::cast_ray_and_get_voxel_key(Self, @dynamics.RigidBodySet3D, ColliderSet3D, Ray3, Float, Bool) -> (ColliderHandle3D, RayIntersection3, (Int, Int, Int))?
pub fn QueryPipeline3DReal::cast_shape(Self, @dynamics.RigidBodySet3D, ColliderSet3D, @core.Isometry3, @core.Vec3, Shape3D, ShapeCastOptions3) -> (ColliderHandle3D, ShapeCastHit3)?
pub fn QueryPipeline3DReal::collider(Self, ColliderSet3D, ColliderHandle3D) -> Collider3D?
pub fn QueryPipeline3DReal::intersect_aabb_conservative(Self, @dynamics.RigidBodySet3D, ColliderSet3D, @core.Aabb3) -> Array[ColliderHandle3D]
pub fn QueryPipeline3DReal::intersect_point(Self, @dynamics.RigidBodySet3D, ColliderSet3D, @core.Vec3) -> Array[ColliderHandle3D]
pub fn QueryPipeline3DReal::intersect_ray(Self, @dynamics.RigidBodySet3D, ColliderSet3D, Ray3, Float, Bool) -> Array[(ColliderHandle3D, RayIntersection3Feature)]
pub fn QueryPipeline3DReal::new(QueryFilter3DReal, @dynamics.RigidBodySet3D, ColliderSet3D) -> Self
pub fn QueryPipeline3DReal::project_point(Self, @dynamics.RigidBodySet3D, ColliderSet3D, @core.Vec3, Float, Bool) -> (ColliderHandle3D, PointProjection3)?
pub fn QueryPipeline3DReal::rigid_body(Self, @dynamics.RigidBodySet3D, @dynamics.RigidBodyHandle) -> @dynamics.RigidBody3D?
pub fn QueryPipeline3DReal::rigid_body_mut(Self, @dynamics.RigidBodySet3D, @dynamics.RigidBodyHandle) -> @dynamics.RigidBody3D?
pub fn QueryPipeline3DReal::update(Self, @dynamics.RigidBodySet3D, ColliderSet3D) -> Unit
pub fn QueryPipeline3DReal::with_filter(Self, QueryFilter3DReal) -> Self

pub struct QueryPipelineMut {
  pipeline : QueryPipeline
}
pub fn QueryPipelineMut::as_ref(Self) -> QueryPipeline
pub fn QueryPipelineMut::new(QueryFilter, @dynamics.RigidBodySet, ColliderSet) -> Self
pub fn QueryPipelineMut::new3(QueryFilter, @dynamics.RigidBodySet3, ColliderSet3) -> Self
pub fn QueryPipelineMut::update(Self, @dynamics.RigidBodySet, ColliderSet) -> Unit

pub struct QueryPipelineMut3DReal {
  pipeline : QueryPipeline3DReal
}
pub fn QueryPipelineMut3DReal::as_ref(Self) -> QueryPipeline3DReal
pub fn QueryPipelineMut3DReal::new(QueryFilter3DReal, @dynamics.RigidBodySet3D, ColliderSet3D) -> Self
pub fn QueryPipelineMut3DReal::update(Self, @dynamics.RigidBodySet3D, ColliderSet3D) -> Unit

pub struct Ray {
  origin : @core.Vec2
  dir : @core.Vec2
}
pub fn Ray::new(@core.Vec2, @core.Vec2) -> Self

pub struct Ray3 {
  origin : @core.Vec3
  dir : @core.Vec3
}
pub fn Ray3::new(@core.Vec3, @core.Vec3) -> Self

pub struct RayIntersection {
  toi : Float
  normal : @core.Vec2
}
pub fn RayIntersection::normal(Self) -> @core.Vec2
pub fn RayIntersection::toi(Self) -> Float

pub struct RayIntersection3 {
  toi : Float
  normal : @core.Vec3
}
pub fn RayIntersection3::normal(Self) -> @core.Vec3
pub fn RayIntersection3::toi(Self) -> Float

pub struct RayIntersection3Feature {
  toi : Float
  normal : @core.Vec3
  feature_id : Int
}
pub fn RayIntersection3Feature::feature_id(Self) -> Int
pub fn RayIntersection3Feature::normal(Self) -> @core.Vec3
pub fn RayIntersection3Feature::toi(Self) -> Float

pub(all) enum Shape {
  Ball(Float)
  Cuboid(Float, Float)
  HalfSpace(@core.Vec2)
  CapsuleX(Float, Float)
  CapsuleY(Float, Float)
  Segment(@core.Vec2, @core.Vec2)
  Polyline(Array[@core.Vec2], Array[(Int, Int)]?)
  HeightField(Array[Float], @core.Vec2)
  ConvexPolygon(Array[@core.Vec2])
  TriMesh(Array[@core.Vec2], Array[(Int, Int, Int)])
  Compound(Array[(@core.Isometry2, Shape)])
  Round(Ref[Shape], Float)
}
pub fn Shape::voxelized_mesh(Array[@core.Vec2], Array[(Int, Int)], Float, FillMode) -> Self

pub(all) enum Shape3D {
  Ball(Float)
  Cuboid(@core.Vec3)
  CapsuleY(Float, Float)
  Cylinder(Float, Float)
  RoundCylinder(Float, Float, Float)
  Cone(Float, Float)
  HalfSpace(@core.Vec3)
  Triangle(@core.Vec3, @core.Vec3, @core.Vec3)
  ConvexHull(Array[@core.Vec3], Float)
  Compound(Array[(@core.Isometry3, Shape3D)])
  Voxels(Voxels3DReal)
  Heightfield(Array[@core.Vec3], Array[(Int, Int, Int)], Int, Int)
  TriMesh(Array[@core.Vec3], Array[(Int, Int, Int)])
}
pub fn Shape3D::ball(Float) -> Self
pub fn Shape3D::capsule_y(Float, Float) -> Self
pub fn Shape3D::cone(Float, Float) -> Self
pub fn Shape3D::cuboid(Float, Float, Float) -> Self
pub fn Shape3D::cylinder(Float, Float) -> Self
pub fn Shape3D::halfspace(@core.Vec3) -> Self
pub fn Shape3D::local_aabb(Self) -> @core.Aabb3
pub fn Shape3D::round_cylinder(Float, Float, Float) -> Self
pub fn Shape3D::triangle(@core.Vec3, @core.Vec3, @core.Vec3) -> Self

pub struct ShapeCastHit {
  toi : Float
  point : @core.Vec2
  normal : @core.Vec2
}
pub fn ShapeCastHit::normal(Self) -> @core.Vec2
pub fn ShapeCastHit::point(Self) -> @core.Vec2
pub fn ShapeCastHit::toi(Self) -> Float

pub struct ShapeCastHit3 {
  toi : Float
  point : @core.Vec3
  normal : @core.Vec3
}
pub fn ShapeCastHit3::normal(Self) -> @core.Vec3
pub fn ShapeCastHit3::point(Self) -> @core.Vec3
pub fn ShapeCastHit3::toi(Self) -> Float

pub struct ShapeCastOptions {
  max_toi : Float
  target_distance : Float
  stop_at_penetration : Bool
}
pub fn ShapeCastOptions::max_toi(Self) -> Float
pub fn ShapeCastOptions::new(Float, Bool) -> Self
pub fn ShapeCastOptions::stop_at_penetration(Self) -> Bool
pub fn ShapeCastOptions::target_distance(Self) -> Float
pub fn ShapeCastOptions::with_target_distance(Self, Float) -> Self

pub struct ShapeCastOptions3 {
  max_toi : Float
  target_distance : Float
  stop_at_penetration : Bool
}
pub fn ShapeCastOptions3::max_toi(Self) -> Float
pub fn ShapeCastOptions3::new(Float, Bool) -> Self
pub fn ShapeCastOptions3::stop_at_penetration(Self) -> Bool
pub fn ShapeCastOptions3::target_distance(Self) -> Float
pub fn ShapeCastOptions3::with_target_distance(Self, Float) -> Self

#alias(ColliderShape)
pub struct SharedShape {
  shape : Shape
}
pub fn SharedShape::as_shape(Self) -> Shape
pub fn SharedShape::ball(Float) -> Self
pub fn SharedShape::capsule_x(Float, Float) -> Self
pub fn SharedShape::capsule_y(Float, Float) -> Self
pub fn SharedShape::cuboid(Float, Float) -> Self
pub fn SharedShape::heightfield(Array[Float], @core.Vec2) -> Self
pub fn SharedShape::new(Shape) -> Self
pub fn SharedShape::polyline(Array[@core.Vec2], Array[(Int, Int)]?) -> Self
pub fn SharedShape::segment(@core.Vec2, @core.Vec2) -> Self
pub fn SharedShape::triangle(@core.Vec2, @core.Vec2, @core.Vec2) -> Self
pub fn SharedShape::trimesh(Array[@core.Vec2], Array[(Int, Int, Int)]) -> Self?

pub struct SolverContact {
  mut point : @core.Vec2
  mut dist : Float
  mut friction : Float
  mut restitution : Float
  mut tangent_velocity : @core.Vec2
}
pub fn SolverContact::dist(Self) -> Float
pub fn SolverContact::friction(Self) -> Float
pub fn SolverContact::new(@core.Vec2, Float) -> Self
pub fn SolverContact::point(Self) -> @core.Vec2
pub fn SolverContact::restitution(Self) -> Float
pub fn SolverContact::set_dist(Self, Float) -> Unit
pub fn SolverContact::set_friction(Self, Float) -> Unit
pub fn SolverContact::set_point(Self, @core.Vec2) -> Unit
pub fn SolverContact::set_restitution(Self, Float) -> Unit
pub fn SolverContact::set_tangent_velocity(Self, @core.Vec2) -> Unit
pub fn SolverContact::tangent_velocity(Self) -> @core.Vec2

#alias(SimdSolverContact)
pub struct SolverContactGeneric {
  point : @core.Vec2
  dist : Float
  friction : Float
  restitution : Float
  tangent_velocity : @core.Vec2
  warmstart_impulse : Float
  warmstart_tangent_impulse : @core.Vec2
  warmstart_twist_impulse : Float
  is_new : Float
  contact_id : Array[Int]
}
pub fn SolverContactGeneric::default() -> Self

pub struct SolverFlags {
  value : Int
}
pub fn SolverFlags::compute_impulses() -> Self
pub fn SolverFlags::contains(Self, Self) -> Bool
pub fn SolverFlags::default() -> Self
pub fn SolverFlags::empty() -> Self
pub fn SolverFlags::insert(Self, Self) -> Self
pub fn SolverFlags::remove(Self, Self) -> Self

pub struct TriMeshFlags {
  value : Int
}
pub fn TriMeshFlags::bits(Self) -> Int
pub fn TriMeshFlags::empty() -> Self
pub fn TriMeshFlags::from_bits(Int) -> Self

pub struct Triangle {
  a : @core.Vec2
  b : @core.Vec2
  c : @core.Vec2
}
pub fn Triangle::as_shape(Self) -> Shape
pub fn Triangle::new(@core.Vec2, @core.Vec2, @core.Vec2) -> Self

pub struct VHACDParameters {
  dummy : Int
}
pub fn VHACDParameters::default() -> Self

pub struct Voxels3DReal {
  voxel_size : @core.Vec3
  columns : @hashmap.HashMap[(Int, Int), Array[Int]]
  dense_origin_x : Int
  dense_origin_z : Int
  dense_nx : Int
  dense_nz : Int
  dense_columns : Array[Array[Int]?]?
  keys : Array[(Int, Int, Int)]
  key_to_id : @hashmap.HashMap[(Int, Int, Int), Int]
  min_key : (Int, Int, Int)
  max_key : (Int, Int, Int)
}
pub fn Voxels3DReal::column_ys(Self, Int, Int) -> Array[Int]?

// Type aliases
pub type ColliderGraphIndex = Int

pub type ModifiedColliders = Array[ColliderHandle]

pub type RigidBodyGraphIndex = Int

pub type TemporaryInteractionIndex = Int

// Traits

