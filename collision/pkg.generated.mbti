// Generated using `moon info`, DON'T EDIT IT
package "Milky2018/moon_rapier/collision"

import {
  "Milky2018/moon_rapier/core",
  "Milky2018/moon_rapier/dynamics",
}

// Values
pub fn handle_user_changes_to_colliders(@dynamics.RigidBodySet, ColliderSet, Array[ColliderHandle]) -> Unit

// Errors

// Types and methods
pub struct ActiveCollisionTypes {
  value : Int
}
pub fn ActiveCollisionTypes::all() -> Self
pub fn ActiveCollisionTypes::default() -> Self
pub fn ActiveCollisionTypes::equals(Self, Self) -> Bool
pub fn ActiveCollisionTypes::test_body_types(Self, @dynamics.RigidBodyType, @dynamics.RigidBodyType) -> Bool

pub(all) enum ActiveEvents {
  CollisionEvents
  ContactForceEvents
}

pub struct ActiveHooks {
  mut value : Int
}
pub fn ActiveHooks::all() -> Self
pub fn ActiveHooks::contains(Self, Self) -> Bool
pub fn ActiveHooks::empty() -> Self
pub fn ActiveHooks::filter_contact_pairs() -> Self
pub fn ActiveHooks::filter_intersection_pair() -> Self
pub fn ActiveHooks::insert(Self, Self) -> Self
pub fn ActiveHooks::modify_solver_contacts() -> Self

pub struct BroadPhaseBvh {
  pairs : Array[(ColliderHandle, ColliderHandle)]
}
pub fn BroadPhaseBvh::as_query_pipeline(Self, @dynamics.RigidBodySet, ColliderSet, QueryFilter) -> QueryPipeline
pub fn BroadPhaseBvh::new() -> Self
pub fn BroadPhaseBvh::pairs(Self) -> Array[(ColliderHandle, ColliderHandle)]
pub fn BroadPhaseBvh::update(Self, Float, @dynamics.RigidBodySet, ColliderSet) -> Unit

pub struct Collider {
  mut shape : Shape
  mut local_translation : @core.Vec2
  mut local_rotation : Float
  mut world_translation : @core.Vec2
  mut world_rotation : Float
  mut active_collision_types : ActiveCollisionTypes
  mut sensor : Bool
  mut active_events : ActiveEvents?
  mut active_hooks : ActiveHooks
  mut collision_groups : @dynamics.InteractionGroups
  mut solver_groups : @dynamics.InteractionGroups
  mut friction : Float
  mut friction_combine_rule : @dynamics.CoefficientCombineRule
  mut restitution : Float
  mut restitution_combine_rule : @dynamics.CoefficientCombineRule
  mut contact_skin : Float
  mut contact_force_event_threshold : Float
  mut user_data : Int
  mut parent : @dynamics.RigidBodyHandle?
  mut enabled : ColliderEnabled
  mut changes : ColliderChanges
}
pub fn Collider::active_collision_types(Self) -> ActiveCollisionTypes
pub fn Collider::active_events(Self) -> ActiveEvents?
pub fn Collider::active_hooks(Self) -> ActiveHooks
pub fn Collider::collision_groups(Self) -> @dynamics.InteractionGroups
pub fn Collider::contact_force_event_threshold(Self) -> Float
pub fn Collider::contact_skin(Self) -> Float
pub fn Collider::friction(Self) -> Float
pub fn Collider::friction_combine_rule(Self) -> @dynamics.CoefficientCombineRule
pub fn Collider::is_enabled(Self) -> Bool
pub fn Collider::is_sensor(Self) -> Bool
pub fn Collider::parent(Self) -> @dynamics.RigidBodyHandle?
pub fn Collider::position(Self) -> @core.Isometry2
pub fn Collider::position_wrt_parent(Self) -> @core.Isometry2?
pub fn Collider::restitution(Self) -> Float
pub fn Collider::restitution_combine_rule(Self) -> @dynamics.CoefficientCombineRule
pub fn Collider::rotation(Self) -> Float
pub fn Collider::set_active_collision_types(Self, ActiveCollisionTypes) -> Self
pub fn Collider::set_active_events(Self, ActiveEvents?) -> Self
pub fn Collider::set_active_hooks(Self, ActiveHooks) -> Self
pub fn Collider::set_collision_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn Collider::set_contact_force_event_threshold(Self, Float) -> Self
pub fn Collider::set_contact_skin(Self, Float) -> Self
pub fn Collider::set_enabled(Self, Bool) -> Self
pub fn Collider::set_friction(Self, Float) -> Self
pub fn Collider::set_friction_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn Collider::set_position(Self, @core.Isometry2) -> Self
pub fn Collider::set_restitution(Self, Float) -> Self
pub fn Collider::set_restitution_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn Collider::set_rotation(Self, Float) -> Self
pub fn Collider::set_rotation_wrt_parent(Self, Float) -> Self
pub fn Collider::set_sensor(Self, Bool) -> Self
pub fn Collider::set_shape(Self, Shape) -> Self
pub fn Collider::set_solver_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn Collider::set_translation(Self, @core.Vec2) -> Self
pub fn Collider::set_translation_wrt_parent(Self, @core.Vec2) -> Self
pub fn Collider::set_user_data(Self, Int) -> Self
pub fn Collider::shape(Self) -> Shape
pub fn Collider::solver_groups(Self) -> @dynamics.InteractionGroups
pub fn Collider::translation(Self) -> @core.Vec2
pub fn Collider::user_data(Self) -> Int

pub struct ColliderBuilder {
  shape : Shape
  mut translation : @core.Vec2
  mut rotation : Float
  mut active_collision_types : ActiveCollisionTypes
  mut sensor : Bool
  mut active_events : ActiveEvents?
  mut active_hooks : ActiveHooks
  mut collision_groups : @dynamics.InteractionGroups
  mut solver_groups : @dynamics.InteractionGroups
  mut friction : Float
  mut friction_combine_rule : @dynamics.CoefficientCombineRule
  mut restitution : Float
  mut restitution_combine_rule : @dynamics.CoefficientCombineRule
  mut contact_skin : Float
  mut contact_force_event_threshold : Float
  mut user_data : Int
  mut enabled : Bool
}
pub fn ColliderBuilder::active_collision_types(Self, ActiveCollisionTypes) -> Self
pub fn ColliderBuilder::active_events(Self, ActiveEvents) -> Self
pub fn ColliderBuilder::active_hooks(Self, ActiveHooks) -> Self
pub fn ColliderBuilder::ball(Float) -> Self
pub fn ColliderBuilder::build(Self) -> Collider
pub fn ColliderBuilder::capsule_x(Float, Float) -> Self
pub fn ColliderBuilder::capsule_y(Float, Float) -> Self
pub fn ColliderBuilder::collision_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder::contact_force_event_threshold(Self, Float) -> Self
pub fn ColliderBuilder::contact_skin(Self, Float) -> Self
pub fn ColliderBuilder::cuboid(Float, Float) -> Self
pub fn ColliderBuilder::enabled(Self, Bool) -> Self
pub fn ColliderBuilder::friction(Self, Float) -> Self
pub fn ColliderBuilder::friction_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn ColliderBuilder::restitution(Self, Float) -> Self
pub fn ColliderBuilder::restitution_combine_rule(Self, @dynamics.CoefficientCombineRule) -> Self
pub fn ColliderBuilder::rotation(Self, Float) -> Self
pub fn ColliderBuilder::segment(@core.Vec2, @core.Vec2) -> Self
pub fn ColliderBuilder::sensor(Self, Bool) -> Self
pub fn ColliderBuilder::solver_groups(Self, @dynamics.InteractionGroups) -> Self
pub fn ColliderBuilder::translation(Self, @core.Vec2) -> Self
pub fn ColliderBuilder::user_data(Self, Int) -> Self

type ColliderChanges

pub(all) enum ColliderEnabled {
  Enabled
  DisabledByParent
  Disabled
}

pub struct ColliderHandle {
  id : Int
  generation : Int
}
pub fn ColliderHandle::equals(Self, Self) -> Bool

pub struct ColliderSet {
  colliders : Array[Collider?]
  generations : Array[Int]
  free_list : Array[Int]
  modified_colliders : Array[ColliderHandle]
}
pub fn ColliderSet::clear_changes_for(Self, Array[ColliderHandle]) -> Unit
pub fn ColliderSet::colliders_with_parent(Self, @dynamics.RigidBodyHandle) -> Array[ColliderHandle]
pub fn ColliderSet::get(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::get_mut(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::get_mut_internal(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::get_mut_internal_with_modification_tracking(Self, ColliderHandle) -> Collider?
pub fn ColliderSet::insert(Self, Collider) -> ColliderHandle
pub fn ColliderSet::insert_with_parent(Self, Collider, @dynamics.RigidBodyHandle, @dynamics.RigidBodySet) -> ColliderHandle
pub fn ColliderSet::new() -> Self
pub fn ColliderSet::remove(Self, ColliderHandle, @dynamics.IslandManager, @dynamics.RigidBodySet, Bool) -> Unit
pub fn ColliderSet::set_parent(Self, ColliderHandle, @dynamics.RigidBodyHandle?, @dynamics.RigidBodySet) -> Unit
pub fn ColliderSet::set_parent_enabled(Self, @dynamics.RigidBodyHandle, Bool) -> Unit
pub fn ColliderSet::take_modified(Self) -> Array[ColliderHandle]

pub struct ContactPair {
  manifold_count : Int
}
pub fn ContactPair::manifold_count(Self) -> Int

pub(all) enum FeatureId {
  Unknown
  Vertex(Int)
  Edge(Int)
  Face(Int)
}

pub struct IntersectionPair {
  collider1 : ColliderHandle
  collider2 : ColliderHandle
  intersecting : Bool
}

pub struct NarrowPhase {
  mut intersections : Array[IntersectionPair]
  mut contacts : Array[(ColliderHandle, ColliderHandle, ContactPair)]
}
pub fn NarrowPhase::contact_pair(Self, ColliderHandle, ColliderHandle) -> ContactPair?
pub fn NarrowPhase::contact_pairs_with(Self, ColliderHandle) -> Array[(ColliderHandle, ColliderHandle, ContactPair)]
pub fn NarrowPhase::intersection_pair(Self, ColliderHandle, ColliderHandle) -> IntersectionPair?
pub fn NarrowPhase::intersection_pairs_with(Self, ColliderHandle) -> Array[IntersectionPair]
pub fn NarrowPhase::new() -> Self
pub fn NarrowPhase::update(Self, @dynamics.RigidBodySet, ColliderSet) -> Unit
pub fn NarrowPhase::update_with_pairs(Self, @dynamics.RigidBodySet, ColliderSet, Array[(ColliderHandle, ColliderHandle)]) -> Unit

pub struct NonlinearRigidMotion {
  start_pos : @core.Isometry2
  linvel : @core.Vec2
  angvel : Float
}
pub fn NonlinearRigidMotion::identity() -> Self
pub fn NonlinearRigidMotion::new(@core.Isometry2, @core.Vec2, Float) -> Self

pub struct PointProjection {
  point : @core.Vec2
  is_inside : Bool
}
pub fn PointProjection::is_inside(Self) -> Bool
pub fn PointProjection::point(Self) -> @core.Vec2

pub struct QueryFilter {
  excluded_body : @dynamics.RigidBodyHandle?
  excluded_collider : ColliderHandle?
  mut groups : @dynamics.InteractionGroups?
  mut flags : QueryFilterFlags
  mut predicate : ((ColliderHandle, Collider) -> Bool)?
}
pub fn QueryFilter::exclude_collider(Self, ColliderHandle) -> Self
pub fn QueryFilter::exclude_dynamic(Self) -> Self
pub fn QueryFilter::exclude_fixed(Self) -> Self
pub fn QueryFilter::exclude_kinematic(Self) -> Self
pub fn QueryFilter::exclude_rigid_body(Self, @dynamics.RigidBodyHandle) -> Self
pub fn QueryFilter::exclude_sensors(Self) -> Self
pub fn QueryFilter::exclude_solids(Self) -> Self
pub fn QueryFilter::groups(Self, @dynamics.InteractionGroups) -> Self
pub fn QueryFilter::groups_filter(Self) -> @dynamics.InteractionGroups?
pub fn QueryFilter::new() -> Self
pub fn QueryFilter::only_dynamic() -> Self
pub fn QueryFilter::only_fixed() -> Self
pub fn QueryFilter::only_kinematic() -> Self
pub fn QueryFilter::predicate(Self, (ColliderHandle, Collider) -> Bool) -> Self

pub struct QueryFilterFlags {
  mut bits : Int
}
pub fn QueryFilterFlags::contains(Self, Int) -> Bool
pub fn QueryFilterFlags::empty() -> Self
pub fn QueryFilterFlags::insert(Self, Int) -> Self
pub fn QueryFilterFlags::new(Int) -> Self

pub struct QueryPipeline {
  filter : QueryFilter
  bodies : @dynamics.RigidBodySet
  colliders : ColliderSet
  aabbs : Array[@core.Aabb?]
}
pub fn QueryPipeline::cast_ray(Self, Ray, Float, Bool) -> (ColliderHandle, Float)?
pub fn QueryPipeline::cast_ray_and_get_normal(Self, Ray, Float, Bool) -> (ColliderHandle, RayIntersection)?
pub fn QueryPipeline::cast_shape(Self, @core.Isometry2, @core.Vec2, Shape, ShapeCastOptions) -> (ColliderHandle, ShapeCastHit)?
pub fn QueryPipeline::cast_shape_nonlinear(Self, NonlinearRigidMotion, Shape, Float, Float, Bool) -> (ColliderHandle, ShapeCastHit)?
pub fn QueryPipeline::collider(Self, ColliderHandle) -> Collider?
pub fn QueryPipeline::intersect_aabb_conservative(Self, @core.Aabb) -> Array[ColliderHandle]
pub fn QueryPipeline::intersect_point(Self, @core.Vec2) -> Array[ColliderHandle]
pub fn QueryPipeline::intersect_ray(Self, Ray, Float, Bool) -> Array[(ColliderHandle, RayIntersection)]
pub fn QueryPipeline::intersect_shape(Self, @core.Isometry2, Shape) -> Array[ColliderHandle]
pub fn QueryPipeline::new(QueryFilter, @dynamics.RigidBodySet, ColliderSet) -> Self
pub fn QueryPipeline::project_point(Self, @core.Vec2, Float, Bool) -> (ColliderHandle, PointProjection)?
pub fn QueryPipeline::project_point_and_get_feature(Self, @core.Vec2, Float, Bool) -> (ColliderHandle, PointProjection, FeatureId)?
pub fn QueryPipeline::rigid_body(Self, @dynamics.RigidBodyHandle) -> @dynamics.RigidBody?
pub fn QueryPipeline::with_filter(Self, QueryFilter) -> Self

pub struct Ray {
  origin : @core.Vec2
  dir : @core.Vec2
}
pub fn Ray::new(@core.Vec2, @core.Vec2) -> Self

pub struct RayIntersection {
  toi : Float
  normal : @core.Vec2
}
pub fn RayIntersection::normal(Self) -> @core.Vec2
pub fn RayIntersection::toi(Self) -> Float

pub(all) enum Shape {
  Ball(Float)
  Cuboid(Float, Float)
  CapsuleX(Float, Float)
  CapsuleY(Float, Float)
  Segment(@core.Vec2, @core.Vec2)
}

pub struct ShapeCastHit {
  toi : Float
  point : @core.Vec2
  normal : @core.Vec2
}
pub fn ShapeCastHit::normal(Self) -> @core.Vec2
pub fn ShapeCastHit::point(Self) -> @core.Vec2
pub fn ShapeCastHit::toi(Self) -> Float

pub struct ShapeCastOptions {
  max_toi : Float
  target_distance : Float
  stop_at_penetration : Bool
}
pub fn ShapeCastOptions::max_toi(Self) -> Float
pub fn ShapeCastOptions::new(Float, Bool) -> Self
pub fn ShapeCastOptions::stop_at_penetration(Self) -> Bool
pub fn ShapeCastOptions::target_distance(Self) -> Float
pub fn ShapeCastOptions::with_target_distance(Self, Float) -> Self

// Type aliases

// Traits

